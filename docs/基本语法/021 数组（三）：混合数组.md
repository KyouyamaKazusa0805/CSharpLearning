# 数组（三）：混合数组

前文我们了解了一种可拆分的数组类型：锯齿数组。今天我们学习的是一种稍微难一点的概念：**混合数组**（Mixed Array）。混合数组是将前面两种数组模型混用，产生的新的数组类型。千万别走神，接下来我们来理解一下混合数组的逻辑。

> 整个这一节的内容的难度都偏大，按需学习。不必掌握它们，但用到的时候，你可以再回来看。

## Part 1 锯齿二维数组里反人类的理解逻辑

既然前面介绍过锯齿的一维数组，那么必然就存在锯齿二维数组。那么，锯齿二维数组是什么样的呢？

```csharp
int[][,] arr = new int[2][,]
{
    new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } },
    new int[4, 5]
    {
        { 6, 7, 8, 9, 10 },
        { 11, 12, 13, 14, 15 },
        { 16, 17, 18, 19, 20 },
        { 21, 22, 23, 24, 25 }
    }
};
```

当然，声明大小的时候，我们可以省略大小。比如例子里 `new int[2][,]` 里的 2、`new int[2, 3]` 里的 2 和 3，还有 `new int[4, 5]` 里的 4 和 5，都是可以不写的。

```csharp
int[][,] arr = new int[][,]
{
    new int[,]
    {
        { 0, 1, 2 },
        { 3, 4, 5 }
    },
    new int[,]
    {
        { 6, 7, 8, 9, 10 },
        { 11, 12, 13, 14, 15 },
        { 16, 17, 18, 19, 20 },
        { 21, 22, 23, 24, 25 }
    }
};
```

不过，你可以看出来，这种写法确实有点古怪。明明是一个锯齿二维数组，结果却是“由若干不同的二维数组构成的大的一维数组”。这正是混合数组里最难搞定的地方。在锯齿一维数组里，我们将 `int[][]` 理解为“整个数组是一个大的 `[]`，每一个元素都是 `[]` 的类型”；而这里也是一样：`int[][,]` 理解成“整个数组是一个大的 `[]`，而每一个元素都是 `[,]` 的类型”。显然，`[]` 表示一个一维数组，而 `[,]` 则表示一个二维数组，所以 `int[][,]` 就是在说，整体是一个一维数组，而每一个元素都是一个二维数组，元素类型由 `int` 的实体构成。

当然，这类数组取值也是和标记 `[][,]` 是一样的：

```csharp
Console.WriteLine(arr[1][2, 3]);
```

我指的是，取值的中括号书写风格是和声明语句里的 `[][,]` 标记是一样的。这里 `arr[1][2, 3]` 表示取 `arr` 里第二个元素（即第二个子数组，就是这个 20 个元素构成的数组）；然后取这个数组里的第 3 行第 4 列的元素。那么显然结果就是 19 了。

尽管有点麻烦，你依然要明白，数组这一点比较严谨的表达逻辑。

## Part 2 二维锯齿数组

如果记号 `[][,]` 反过来呢？`[,][]` 又能表达什么呢？

```csharp
int[,][] arr = new int[2, 3][]
{
    {
        new int[1] { 1 },
        new int[2] { 2, 3 },
        new int[3] { 4, 5, 6 }
    },
    {
        new int[4] { 7, 8, 9, 10 },
        new int[5] { 11, 12, 13, 14, 15 },
        new int[6] { 16, 17, 18, 19, 20, 21 }
    }
};
```

看这个例子。这个例子告诉你，实际上整个数组类型 `int[,][]` 想表示一个二维数组，只是下面的每一个元素都是一个一维数组类型的实体。和前面的理解方式完全类似：`int[][,]` 理解成“`int` 元素、大数组是 `[]` 类型，每一个元素都是一个 `[,]`”。这里 `int[,][]` 就可以理解成“`int` 元素、大数组是 `[,]` 类型，每一个元素都是一个 `[]`”。

> 我不是很想要提名字。前面那种叫锯齿二维数组，而这个叫二维锯齿数组。注意名字的顺序。将“二维”放在前面和放在后面是不一样的：二维锯齿数组是在说，数组本身就是二维的，只是元素是锯齿数组；而“锯齿”放在前面，则在说明数组本身是锯齿的数组，只是数组的元素类型并不是等大小的一维数组了，而是二维数组。

## Part 3 我就要搞事情

简单看个例子就可以了。

```csharp
int[][][] arr1 = new int[3][][]
{
    new int[2][]
    {
        new int[] { 1 },
        new int[] { 3, 5 }
    },
    new int[3][]
    {
        new int[] { 2, 4, 6 },
        new int[] { 8, 10, 12, 14 },
        new int[] { 16 }
    },
    new int[4][]
    {
        new int[] { 2 },
        new int[] { 3, 5, 7, 11 },
        new int[] { 13, 17 },
        new int[] { 19, 23, 29 }
    }
};
```

然后自己想想 `int[,][][]` 啊、`int[][,][]` 啊、`int[][][,]` 都是些啥玩意儿。反正我们也用不上。

## Part 4 混合数组的遍历

混合数组的遍历，一旦搞清楚层次关系和逻辑的时候，我们就可以直接开始遍历了。我们拿基础的锯齿二维数组来遍历：

```csharp
int[][,] arr = new int[][,]
{
    new int[,]
    {
        { 0, 1, 2 },
        { 3, 4, 5 }
    },
    new int[,]
    {
        { 6, 7, 8, 9, 10 },
        { 11, 12, 13, 14, 15 },
        { 16, 17, 18, 19, 20 },
        { 21, 22, 23, 24, 25 }
    }
};
```

显然，一旦清楚逻辑后，我们就可以遍历它们了：

```csharp
foreach (int[,] subarr in arr)
{
    foreach (int element in subarr)
    {
        Console.WriteLine(element);
    }
}
```

再复杂一点：

```csharp
foreach (int[,] subarr in arr)
{
    for (int i = 0; i < subarr.GetLength(0); i++)
    {
        for (int j = 0; j < subarr.GetLength(1); j++)
        {
            Console.WriteLine(subarr[i, j]);
        }
    }
}
```

再复杂一点：

```csharp
for (int k = 0; k < arr.Length; k++)
{
    int[,] subarr = arr[k];
    for (int i = 0; i < subarr.GetLength(0); i++)
    {
        for (int j = 0; j < subarr.GetLength(1); j++)
        {
            Console.WriteLine(subarr[i, j]);
        }
    }
}
```

再复杂一点：

```csharp
for (int k = 0; k < arr.Length; k++)
{
    for (int i = 0; i < arr[k].GetLength(0); i++)
    {
        for (int j = 0; j < arr[k].GetLength(1); j++)
        {
            Console.WriteLine(arr[k][i, j]);
        }
    }
}
```

