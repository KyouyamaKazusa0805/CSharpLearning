<!--还没写完-->

# 第 118 讲：C# 5 之异步方法（一）：初见 `Task`

欢迎来到 C# 5！C# 5 的特性也是特别少：

* **异步方法**（Asynchronous Method）；
* **调用方信息特性**（Caller Member Information）；
* `foreach` 循环迭代变量的行为修改。

不过第一个特性“异步方法”可以说的内容就多了去了。它也和 LINQ 一样，体系特别庞大。虽然我们能用的语法上的特性只有两个新增的关键字 `async` 和 `await` 而已，但是这两个关键字却是众多新人 C# 玩家望而却步的绊脚石。

> 望而却步的绊脚石……这话咋这么别扭……

## Part 1 浅谈 `Task` 类型

C# 5 开始提供一种新的类型使用：`Task`。这个类型用来更方便地控制多线程的处理机制。而实际上这个类型早在 C# 4 就已经存在了，但是当时没有新语法的使用，虽说那时候也很方便了，不过仍然没有非常方便。

> 你还别不信。很多人都以为 C# 5 拥有的新语法才有的 `Task`。实际上你可以去看看微软提供的文档。`Task` 在 .NET Framework 上的 4.0 版本就有了这个类型。而对比我最开始给大家列举的语法对应的框架表，你就会发现，.NET Framework 4.0 实际上已经包含的是 C# 4 的相关语法。

实际上，这个类型名称虽然叫 `Task`，但实际上它包含两种类型：

* `Task`：无泛型参数，用于控制无返回值的异步方法；
* `Task<T>`：有泛型参数，用于控制带有返回值的异步方法。

其中，带泛型的 `Task<>` 类型是 `Task` 的派生类型，是这么一个关系。

那么，`Task` 和 `Task<>` 是什么呢？它的存在意义在哪里呢？为什么 C# 都更新到第 5 个版本了还在添加多线程的数据类型呢？下面我们就来说一下。

> 经过深思熟虑之后，我决定使用《C# 本质论》上面介绍的异步方法的语法使用和处理机制给大家作为异步方法这个语言特性的介绍大纲。因为我能力也有限，容易忘掉很多东西，我怕讲解了这边之后，又忘记了那边。因此本文包括后面异步方法的相关内容，也都参考了《本质论》这本书上的提供资料和描述内容。
>
> 当然，这肯定不是抄，我也肯定不会去抄袭（特别是大段大段地引用原话），你可以打开你的这本书参考这些内容，看看我到底有没有真的在抄袭。

### 1-1 多线程的复杂性

回忆一下多线程。多线程给我们带来的一个感觉就是：快。因为它提升了 CPU 的使用率，让我们同一个时间段可以同时做很多事情，而不再是一件事。显然一定时间段内同时做多个事情效率会更高，因此我们会有这种感觉。且不说它理论上到底对不对，但至少我们的体验是极好的。

但是，多线程也带来了很多不便。因为它要灵活使用 CPU，所以多线程的处理会非常麻烦。主要体现在如下的这些方面：

#### 1-1-1 不可控和轮询阻塞主线程

有时候会需要监控操作期间的多线程状态。有些时候我们一旦发出多线程的指令就无法控制这个多线程的代码执行的情况。我们要像监控一个多线程处理单位，有时候会使用上死循环来卡住主线程，这个形成我们称为**轮询**（Polling），即“一轮一轮地循环”的意思。这样的话，等待这个处理过程结束之后，死循环会跳出，然后继续往后执行。但是这样做的坏处就是，它会卡住主线程（专业一点说呢，就叫**阻塞**（Block）主线程），使得这个时候主线程不能做任何其它的事情。主线程在等待开辟的新线程完成事情之前都是在死循环之中的。这个时候我们无法对主线程执行任何其它操作。

#### 1-1-2 线程池

既然我们知道开辟线程在执行期间不可控制，那么我们能做的、可控的办法就是使用线程池。但是线程池也有问题，比如线程池的线程也并非你在发出指令的那一刻开始立刻执行。换句话说，这个线程并非是我们让它开始它就会开始的。另外，线程池里的线程处理单位都是后台线程，这意味着我们关闭程序或控制台的时候，这样的线程会被自动终止掉，如果有些时候我们确实不希望它这样，那么线程池就没办法搞了。总之线程池也有非常多的使用讲究，因此也不是一件容易的事情。

#### 1-1-3 死锁机制

**死锁**（Deadlock）。死锁机制是多线程里经常会遇到的情况。它指的是处理期间，两个线程互相在等待对方导致的同时卡住的情况。我举个例子你就明白了。

你去面试，面试官问你，“请说说死锁的意思。说对了我就让你通过”。然后你跟他说，“你先让我过，我就给你说说死锁”。仔细理解双方的对话内容，你就会发现。我在等待面试官给我机会通过，而面试官此时也在等待我说出死锁的意思。双方互不相让，而条件只要能继续进行其中一个，这个看似环状的逻辑就会被断开，整个流程也会直接瓦解并结束。

导致死锁的四大条件是：

* **互相排斥**（一般简称**互斥**，Mutual Exclusion）：指的是一个东西只能在同一时刻被一个人/物体所用。体现在刚才的例子里，就是面试通过的这个条件。你想要去先拿到通过条件，但是这一关被面试官守着呢。面试官不让你过，这个条件你就始终触碰不到。这个就叫互斥；
* **请求和保持**（Hold & Wait）：指的是第一点提到的这个“东西”被死死地守护住，不让外界随意触碰。在这个例子里就说的是面试官死死守住条件不外放。它和第一点强调的内容不同。第一点说的是事物只能在同一个时刻被一个人/物所用；而这里说的是被守护住之后不会释放出去给别人所用；
* **不可抢占**（No Preemption）：指的是第一点提到的这个“东西”不可被任何其它人/物所剥夺或者抢占而据为己有、留为自己所用。换句话说，这个东西只能被守护的这一方释放出去之后，才可以继续提供别人使用。对应到例子里就是在说，面试官必须要发出条件才可让“我”拿到，而我是无法强制性地打面试官一顿然后威胁 ta 把通过条件给我的；
* **循环等待**（Circular Wait）：指的是第一点所提到的这个“东西”对于两个或更多个处理过程来说，是一种蛇头咬蛇尾的循环关系：A 在等待 B 释放，B 在等待 C 释放，而 C 却又在等待 A 的释放。体现在例子里，因为例子只有两个人围绕这个“通过条件”在说事，因此就没有所谓的 C 了，而是 A 等 B 并且 B 等 A 的状态，这只不过是少一个节点，但仍然是呈现为环状的关系的。

> 在第二点的英文术语词 hold and wait 里，hold 是抓住、掌握住的意思。中文一般翻译成“请求和保持”。这个“请求”对应到的英文是这里的 hold，但翻译上不妥。当然，它可能强调的点在另外一方（想要使用这个东西的一方，而不是守护这个东西的一方），但是从英语的翻译里是对应不上的。这里要说清楚，否则会有人钻牛角尖。

倘若上述四个条件任何一个不满足，都不会造成死锁。

* 如果没有互斥，那么面试官掌权我就可以直接拿到（注意强调点在我主动去拿条件），显然不会让两个人陷入焦灼的状态；
* 如果没有请求和保持，那么面试官可以下放条件给我（注意强调点在面试官下放条件，释放掉这种守护权），我也会直接通过，因此也不会出现焦灼的状态；
* 如果没有不可抢占，那么我就可以打面试官然后剥夺此通过条件（虽然我们不鼓励），那么这也不会造成两个人焦灼的状态；
* 如果没有循环等待，要么他不等我说，直接取消面试环节，换下一个人，要么我直接退出了，那么都不会造成焦灼的状态。

在多线程里也常常会出现这个状况。就单说这一点，多线程就比单线程考虑的东西要多。

#### 1-1-4 原子性

多线程存在一种情况。虽然我们宏观上看是在同时做很多事情，但在微观来说，多线程实际上也是在很短的时间范围（我们称为**时间片**，Timeslice）之中交替执行的。如果我们放大时间片，就会发现，确实是 A 做了这一段时间之后交换执行权利给 B，然后 B 执行一段时间之后又还给 A 继续做。如果 CPU 不设计这种处理的话，那么 CPU 再好的性能，也会被线程数量多起来的时候导致 CPU 的 100% 资源都被占用。这个时候要我还想继续执行别的线程可就没位置进来了，那么只能等待。如果有这么个机制的话，再多的话，我们交替着做，就都可以顾及到。

不过，有些时候比较极端。如果时间片刚好用完，可我这个任务的某一个步骤没完成，比如说 `i = i + 30` 操作需要先计算 `i + 30` 的结果，然后返还给 `i` 变量。那么我如果已经算出了 `i + 30` 了，但是还没往 `i` 赋值回去，时间片时间就到了，然后就切换执行之后，`i` 还保持了原来的数值，虽然我们知道 `i` 应该更新数值，但操作已经结束，因此 `i + 30` 的结果赋值回去只能等待下一次时间片轮到这个线程继续做的时候才能赋值了。那么这个时候就存在 `i` 出现完全不一致的数据的两个情况。

于是我们约束这种情况出现，发明了原子机制。所谓**原子性**（Atomic），指的是一个操作无法从微观角度来说继续拆解，比如 `i += 30` 就是非原子性的，因为它可以拆解成“`i + 30` 计算”和“赋值给 `i`”两个操作。原子性的代码操作使得我们可以控制这段语句必须在我执行完毕了之后才能切换时间片，给别的线程继续。虽然这么做是可以，但它显然增大了多线程使用的难度和复杂性。实际上这个世间万物，绝大多数操作都是非原子的，所以要考虑这种东西就会显得特别复杂。

综上所述，多线程具有上面给出的这样四种复杂的情况。为了更加方便易用、提高多线程的可编程性，.NET 再三更新和制定新的多线程框架和使用规范，因此，多线程才会到现在仍然有更新迭代。

### 1-2 从 `Thread` 到 `Task`

