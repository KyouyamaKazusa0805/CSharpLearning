# C# 2 之委托逆变参数和协变返回

我们经常使用委托来“代理”一个函数。我们使用 `new 委托(方法名)` 的方式来告诉运行时，我这个方法我将在以后会用到，并且执行，但不是现在。可某些时候，问题总是离谱的。

C# 2 对委托类型有三个扩展语法规则，其中两个“方法组转换”和“匿名函数”已经说过了，下面要说的是第三种语法规则，它包含下面两种情况：

* **协变返回**（Covariance on Return）
* **逆变参数**（Contravariance on Parameter）

它们均针对的是委托类型赋值方的方法组。

## Part 1 理解委托的逆变参数

本讲的内容较为抽象，所以我们直接上例子教大家和告诉大家如何使用。

```csharp
delegate void MammalHandler(Mammal mammal);
```

假如我有这么一个委托类型，它传入一个 `Mammal` 类型的实例，用作处理功能的这么一个委托类型。顺带一说，mammal 单词的意思是“哺乳动物”。如果按正常的逻辑去理解这句话的话，这个委托类型大概可以理解为“用来处理一个哺乳动物的委托对象”。

那么，我们要想正确使用这个委托类型，我们的代码自然是这样的：

```csharp
MammalHandler handler = delegate (Mammal mammal)
{
    // Do something.
};
```

用上我们才学的匿名函数。我们既然知道参数必须是 `Mammal` 类型，那么我们直接这么写即可。那么，思考一下。假设我现在有这么一个派生关系：

```csharp
abstract class Animal { }
sealed class Mammal : Animal { }
sealed class Cat : Mammal { }
```

以下的两个代码，有没有正确的？

```csharp
// Option 1: Use 'Animal'.
MammalHandler handler = delegate (Animal animal)
{
    // Do something.
};

// Option 2: Use 'Cat'.
MammalHandler handler = delegate (Cat cat)
{
    // Do something.
};
```

可能，你会觉得两种都是错误的语法格式，因为我们的类型是不匹配的：要求参数是 `Mammal` 类型，怎么也得传入的是 `Mammal` 类型才对。实际上，最开始的委托类型也确实如此，但是，在 C# 2 里，我们会允许 option 1（即传入的 `Animal` 类型的这个情况）可以用于此处的代码。换句话说，option 1 从 C# 2 开始可以允许这么使用，代码的语法是正确的。

是不是挺奇怪的？按道理说，我要得传入一个哺乳动物进去，而这个派生关系上，猫咪才是哺乳动物，那么怎么说也得是 option 2 才是对的语法啊，为啥是 option 1？

我们这里稍微说明一下这个奇怪的原因。思考一下，

## Part 2 理解委托的协变返回



## Part 3 这种优化机制的意义何在？

