# C# 2 之委托逆变参数和协变返回

我们经常使用委托来“代理”一个函数。我们使用 `new 委托(方法名)` 的方式来告诉运行时，我这个方法我将在以后会用到，并且执行，但不是现在。可某些时候，问题总是离谱的。

考虑一种情况。倘若我有一个 `Shape` 的类型，它表示一个形状，并且派生出了 `Circle`、`Rectangle` 等类型。

```csharp
abstract class Shape { }

sealed class Circle : Shape
{
    private readonly int _radius;

    public Circle(int radius) { _radius = radius; }

    public int Radius { get { return _radius; } }
}
sealed class Rectangle : Shape
{
    private readonly int _width, _height;

    public Rectangle(int width, int height)
    {
        _width = width;
        _height = height;
    }

    public int Width { get { return _width; } }
    public int Height { get { return _height; } }
}
```

假设我们就用这两种类型来举例。

假设我们由于考虑不周全，尚未扩展 `Shape` 类型，导致我们现在需要额外添加一个 `GetArea` 方法（假设用来计算图形实例的面积）的时候无法加到程序代码里。那么我们只能在这些已经写死的代码的外部，追加额外的代码来完成计算面积的操作了。

那么我们来使用这个方案来完成。首先我们试着写一个委托类型。

```csharp
delegate double AreaCalculator(Shape shape);
```

比如这个委托类型 `AreaCalculator`，它可以执行一个方法，来计算一个 `Shape` 实例的面积，并且返回出来（以 `double` 类型数据表示）。那么，我们可以在执行代码的地方预先给出两个图形的具体计算过程：

```csharp
class Program
{
    private static void Main()
    {
        AreaCalculator a = new AreaCalculator(CircleArea); // Does it work?
        AreaCalculator b = new AreaCalculator(RectangleArea); // Does it work too?

        Circle circle = new Circle(3);
        Rectangle rect = new Rectangle(3, 4);
        double circleArea = a.Invoke(circle);
        double rectArea = b.Invoke(rect);

        Console.WriteLine(circleArea);
        Console.WriteLine(rectArea);
    }

    private static double CircleArea(Circle circle)
    {
        int r = circle.Radius;
        return Math.PI * r * r;
    }

    private static double RectangleArea(Rectangle rect)
    {
        int w = rect.Width, h = rect.Height;
        return w * h;
    }
}
```

请注意这里给出的 `Main` 方法的代码。第 7 行的代码使用了 `new AreaCalculator(CircleArea)` 语句来实例化委托对象。但问题在于，参数类型并不匹配：`AreaCalculator` 类型要求参数必须是 `Shape` 类型，而返回值必须是 `double` 类型；可问题是我这里给出的 `CircleArea` 方法下，它的参数类型却是 `Circle` 类型，而返回值倒是 `double` 类型，是对的。

那么，这样的代码合理、合适吗？我相当于是用了 `Shape` 类型的派生类型来做这个事情的，正是因为参数仅用于传入，因此我们直接用派生类去替换 `Shape` 类型，倒也说得通：因为我的派生类型是走 `Shape` 类型派生下来的，那么 `Shape` 具有的东西我的派生类型应该也都有才是。那么，这么去使用的话，确实也没有错。可 C# 并不允许这样的语法，是吧？

是的，C# 的原生语法里，确实不允许这样的写法（如果实例化用的方法名的参数类型和委托给的参数类型不匹配，是会产生编译器错误的）。但是在 C# 2 里，该语法有所拓展：**允许委托类型的参数在实例化委托的时候，用派生类型替换掉基类型**。其中，使用派生类型来代替基类型，我们称为**逆变**（Contravariation），你可以理解为基类型到派生类型的使用是一个“从模糊类型到具体类型”的过程，那么“宽到窄”就是一种反着来的操作，所以就叫它“逆变”了。那么，用术语来解释这个现象的话，就是“委托参数的可逆变性”。
