# C# 2 之方法组转委托

本节内容也跟委托类型有关。可以知道，委托在 C# 里的重要性。

## Part 1 从另一个维度简化委托类型实例化

前文我们介绍了匿名函数的机制，它允许我们实例化一个自己额外定义的方法，并允许捕获变量的机制。那么，假如我们的方法本身就存在呢？

考虑一点。我要遍历序列，并执行指定的操作来使用每个序列里的元素。比如：

```csharp
static void PrintList<T>(List<T> list, Action<T> printer)
{
    foreach (T element in list)
    {
        printer.Invoke(element);
    }
}
```

这个 `Action<T>` 就表示我们对每一个元素执行什么操作。那么，假设我调用是用来输出显示，那么，我可以这么写代码：

```csharp
List<int> list = new List<int>();
list.Add(1);
list.Add(3);
list.Add(10);
list.Add(60);

PrintList(list, delegate (int element) { Console.WriteLine(element); });
```

是吧。很容易理解，就是把数据得到后，直接调用 `Console.WriteLine` 方法去输出。

可是，有必要这么写吗？你看看，我下面这样的写法对不对：

```csharp
PrintList(list, new Action<int>(Console.WriteLine));
```

是的，绑定上了一个方法组。这是我们之前讲到的一个新鲜玩意儿：它绑定上匹配签名的方法，直接充当委托的实例调用方法，这样，在执行 `PrintList` 方法的时候，参数 `printer` 绑定了这个方法就会自动去执行它。所以，这么写也是没错的语法。

> 顺带一提，这里的 `Console.WriteLine` 方法，你可以仔细看看这个 API。它有很多重载，正是因为如此，`Console.WriteLine` 这个写法才叫做方法组。但是，因为我们实例化的类型是 `Action<int>` 类型，因此对应的签名是 `void Action<int>(int)` 一样的东西。而 `Console.WriteLine` 方法组里包含传入 `int` 不返回值的重载版本，因此这样实例化是正确的。

而这样的实例化语法 `new Action<int>(Console.WriteLine)`，因为参数类型是我们已知的，因此 C# 2 简化了此语法，不再要求你必须 `new Action<int>` 了：

```csharp
PrintList(list, Console.WriteLine);
```

是的。可以发现这样的写法简单了不少。这种语法特性叫做**方法组自动转换为委托类型**，简称**方法组转换**（Method Group Conversion），因为方法组一般也就只能用在委托里，所以“方法组转换为委托”的“为委托”不用说，都知道是转换成委托类型实例的。

当然，这种语法不一定非得用于参数，也可以是委托类型的变量定义过程：

```csharp
Action<int> f = Console.WriteLine;
```

等等。

## Part 2 没了？

是的，没了。这个语言特性是从另外一个维度简化委托类型实例化的格式，因此也没有必须要单独去提及的点。