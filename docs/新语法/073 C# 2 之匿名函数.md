# C# 2 之匿名函数

还记得前面学习的委托吗？我们仍使用排序来举例。

## Part 1 引例

假设，我们需要使用委托传参的方式来表示数组排序 `Array.Sort` 方法，而我们也学习了如何调用这个方法：

```csharp
int[] arr = { 3, 8, 1, 6, 5, 4, 7, 2, 9 };
Array.Sort(arr, new Comparison(Compare));


static int Compare(int a, int b) { return a.CompareTo(b); }
```

是的，这样的代码就可以完成排序。可是，这样代码仍然很长。因为我们要自己写一个方法，而且还得使用 `new Comparison` 来实例化委托对象来作为传参过程。因此，C# 2 开始，为了简化语法，发明了一种新的语法格式：**匿名函数**（Anonymous Function）。

## Part 2 匿名函数的语法

我们先来看简化版代码应该怎么写：

```csharp
int[] arr = { 3, 8, 1, 6, 5, 4, 7, 2, 9 };
Array.Sort(arr, delegate (int a, int b) { return a.CompareTo(b); });
```

当然，也可以换个行：

```csharp
int[] arr = { 3, 8, 1, 6, 5, 4, 7, 2, 9 };
Array.Sort(
    arr,
    delegate (int a, int b)
    {
        return a.CompareTo(b);
    }
);
```

是的，就两个语句即可。其中第二个语句有些奇怪。第一个参数仍然没有改变，但第二个参数变长了。其实也是猜得到的：因为实际的方法不见了，改成了这样的语法被替换到了参数的位置上。

仔细看这个参数写法 `delegate (int a, int b) { return a.CompareTo(b); }`，它就被称为匿名函数。

匿名函数的语法如下：

```antlr
匿名函数
    'delegate' ('(' 参数表列 ')')? '{' 执行代码 '}'
```

匿名函数的作用就是为了简化委托类型的实例化。它的写法是直接将“方法的关键部分”参数化，直接写进参数里。这种写法大大改变了你书写代码（特别是用委托的时候）的风格和习惯。因此，你必须要习惯这种书写格式。

它的语法格式是这样的。参数表列直接对应了我们这里的 `Comparison<T>` 委托类型的参数表列。因为我们这里对数组排序，因此比较的是两个 `int` 数据，因此我们直接写 `(int a, int b)` 即可；与此同时，我们直接把执行代码和前面的 `a.CompareTo(b)` 抄过来就可以了。因此，这个匿名函数长这样。

之所以叫匿名函数，就是因为它没有方法名称，而不论什么时候，委托的实例化代换为匿名函数语法的时候都是直接退化为了 `delegate` 关键字了，所以这样的方法是没有名字的。

当然，也有其它的方法也可以使用到这个语法。比如这样的代码：

```csharp
bool allElementsAreEven = Array.TrueForAll(
    arr,
    delegate (int element) { return element % 2 == 0; }
);
```

这个 `Array.TrueForAll` 方法表示验证整个数组序列是不是全部的元素都满足同样的条件。而这个条件，就从第二个参数进行指定。所以，第二个参数是一个条件的委托实例。我们这里只需要验证元素的数据，所以这个匿名函数需要一个参数，并返回 `bool` 结果。

是的，你说对了。`Array.TrueForAll` 方法的第二个参数的类型就是 `Predicate<T>`。

## Part 3 委托实例化转匿名函数的套路

其实前面基本上可以搞懂如何简化这样的代码，用上匿名函数。不过，我还是简单说一下，如何从原生代码转换为匿名函数语法。

### 3-1 第一步：看委托类型的签名，确定参数和返回值类型

如何转换语法？先看委托类型。匿名函数用就用在委托类型实例化之上，所以一定要把眼睛关注到委托类型上。先看委托类型的签名，这样就可以确定返回值和参数的类型。

比如说，我的委托类型定义为这样：

```csharp
delegate void Swapper(ref int a, ref int b);
```

那么它的参数类型是 `ref int`、`ref int`，而返回值类型则是 `void`。

### 3-2 第二步：脑内推测方法的完整语法

第二步是在脑内构造一个方法，契合这个签名的。按照委托类型的尿性，我们一般不在意方法是不是 `static` 修饰的，所以我们不必去管方法自身的修饰符，只大概想一想它的参数和返回值放上去后是啥样的。

这个时候，得看方法的实际使用过程来确定具体的代码执行逻辑。因为 `Swapper` 委托类型的名字是“交换”的类似意思，所以我们实现的时候就得考虑是不是用于交换变量了。显然，参数类型都是带有 `ref` 修饰符的，它的意图已经很明显了：没有 `ref` 修饰符就是复制副本，因此无法完成交换过程。正是因为交换需要方法内外都使用同一个数据信息，因此 `ref` 修饰符才得以存在。正是因为这个修饰符，所以我们才可以推断得到这样的实现逻辑。

那么既然是交换，我们就直接在里面写上交换逻辑即可。

```csharp
void Function(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

### 3-3 第三步：去掉返回值类型，把方法名替换为 `delegate` 关键字

那么，匿名函数的作用是把 `匿名函数语法` 代替掉原来的 `new 委托(方法名)`，因此我们仅需要替换掉返回值类型和方法名。于是乎，刚才的代码可以改写成这样：

```csharp
delegate (ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

至此，匿名函数就改写完成了。

### 3-4 特殊情况：无参匿名函数

这里稍微说一下一种特殊情况：无参数的匿名函数。

**C# 允许无参匿名函数省略这参数的这对小括号**。所谓的省略，就是允许直接不写这对括号。假设一个委托类型是 `Action` 的话，那么这种情况的方法的签名里，参数是为空的。正是因为这样的情况，匿名函数的原本语法应该长这样：

```csharp
delegate ()
{
    // Do something.
}
```

而这种情况下，小括号可以不写。因此，无参匿名函数的写法可以去掉这对小括号：

```csharp
delegate
{
    // Do something.
}
```

