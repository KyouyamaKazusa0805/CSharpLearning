# 模式匹配

## 模式匹配是啥？

**模式匹配**（Pattern Matching），在编程里指的是，把一个不知道具体数据信息的玩意儿，通过一些固定的语法格式来确定模式数据的具体内容的过程。

C# 的模式匹配非常美丽，因为语法格式非常有趣、简单、且更具有可读性。下面我们来看看 C# 的模式匹配。

## C# 各种各样的模式

C# 里有很多种类的、用来控制和判断数据的**模式**（Pattern），它们语法不同，判断的东西、语义也不一样。下面我们列举它们。

### 声明模式（Declaration Pattern）

#### 1、语法

声明模式用于简单判断一个模糊的数据类型是否是某个具体的数据类型，并尝试将其转换过去。

```csharp
object greeting = "Hello, World!";
if (greeting is string message)
    Console.WriteLine(message.ToLower());
```

注意语法 `greeting is string message` 的写法。C# 最开始允许 `is` 的写法是 `obj is T`，而 `T` 之后写的变量指的是“如果 `obj` 确实是 `T` 类型的实例的话，那么 `message` 就可以使用了”。换句话说，这段代码等价于下面这样的代码：

```csharp
object greeting = "Hello, World!";
if (greeting is string)
{
    string message = (string)greeting;
    Console.WriteLine(message.ToLower());
}
```

即在大括号里等效进行类型转换。

#### 2、声明模式仍可能会进行拆箱

假设我们原始的对象是装箱的操作：

```csharp
object o = 3;
```

那么，即使你使用这个语法来获取结果：

```csharp
if (o is int v)
    Console.WriteLine(v);
```

它也避免不了拆箱行为：因为它等于 `o is int` 后直接进行 `int v = (int)o` 的拆箱赋值操作，所以它会隐式地进行拆箱，它是避免不了的。

### `var` 模式（`var` Pattern）

#### 1、语法

有一些时候，我们可以内联模式匹配和变量声明。

```csharp
static bool IsAcceptable(int length, int absLimit)
    => SimulateDataFetch(length) is var results
    && results.Min() >= -absLimit
    && results.Max() <= absLimit;

static int[] SimulateDataFetch(int length)
{
    var rand = new Random();
    int[] result = new int[length];
    for (int i = 0; i < length; i++)
        result[i] = rand.Next(-100, 100);

    return result;
}
```

我们来看下这个例子。`SimulateDataFetch` 方法获取指定长度的数组，数组的每个元素都是 -100 到 100 之间的随机数。`IsAcceptable` 方法则是验证序列是不是在某个数字的范围内。可以从例子里看出，我们直接将方法调用的结果直接内联到 `return` 语句里，我们写的是 `is var results`。这个语句和下面这段代码相当：

```csharp
int[] results = SimulateDataFetch(length);
return results.Min() >= -absLimit && results.Max() <= absLimit;
```

#### 2、声明模式和 `var` 模式的区别

请稍微注意一下。`var` 模式和声明模式的书写格式完全一样，唯一的区别是，一个写的是类型的具体名称，一个则是写的固定的关键字 `var`。声明模式下，写的数据具体类型会作为数据的判断类型进行判断；而 `var` 仅等价于变量声明，它并不具有任何的数据类型的判断。

虽然我们可以看到，`var` 模式的例子里，由于 `SimulateDataFetch` 方法返回的 `int[]` 类型是固定的，因此我们完全可以写成 `SimulateDataFetch(length) is int[] results`。而且它们没有运行时和编译期间的差异，写 `var` 和 `int[]` 都行。不过我们更建议在模式匹配里使用 `var` 进行一劳永逸地使用变量定义规则，统一变量定义的语法。如果随时都是显式类型定义的话，每次修改返回值都有可能导致编译失败。

### 常量模式（Constant Pattern）

#### 1、语法

常量模式针对于一个可能为 `null` 的数据类型的实例，判断是否等于某个具体的常量。

```csharp
object o = 3;
if (o is 30)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

在这段代码下，我们直接在 `is` 后紧跟一个数值，这表示将 `object` 进行类型和数值的双重判断。等价的代码是这样的：

```csharp
object o = 3;
if (o is int i && i == 30)
    Console.WriteLine("The condition is true.");
```

那么，为什么非得是 `int` 呢？因为这里的 3 这个字面量，默认是 `int` 类型的，因此这里在等价代码里用的是 `int` 作为类型的判断。

#### 2、可空值类型的常量模式匹配是不必要的

另外，我们也可以对一个可空值类型使用这样的常量模式判断。

```csharp
int? i = null, j = 30;
if (i is 3 && j is 3)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

比如这个格式。这个格式很明显等价于 `i is int p && p == 3 && j is int q && q == 3`。正是因为写起来很长，所以我们才会使用这样的模式匹配来简化代码。不过，这个模式匹配是不必要的。早在可空值类型出现的时候，它们自身的等号和不等号的逻辑就已经可具有这样的判断了。换句话说，你写成这样，和模式匹配的格式将是一样的等价代码。

```csharp
int? i = null, j = 30;
if (i == 3 && j == 3)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

这里，`i` 就算是 `null`，也不会影响判断 `i == 3` 的结果。大不了结果为 `false` 就是了。

#### 3、`double.NaN` 的特殊处理

假设我们用 `is double.NaN` 对一个对象进行数值匹配：

```csharp
if (d is double.NaN)
    // ...
```

这表示什么？`d == double.NaN` 吗？虽然好像没啥毛病，但是大家也都知道，`double` 类型的等号比较是严格的，因此很多时候比较起来都不一定相等。因此，C# 的 API 有一个 `double.IsNaN` 方法在专门对这个情况进行判断。而此时的 `d is double.NaN` 就刚好是在调用此方法。也就是说，这个 `if` 条件会被翻译为这样：

```csharp
if (d is double && double.IsNaN((double)d))
    // ...
```

是的。类型判断后，然后直接调用此方法来判断，而并非是 `d == double.NaN`。

### 对位模式（Positional Pattern）

#### 1、语法

对位模式是将一个数据成员通过解构方法来产生解构，来判断属性数据的过程。假设我们拥有这样一个数据类型：

```csharp
public readonly struct Point
{
    public int X;
    public int Y;
}
```

显然这里的 `X` 和 `Y` 是 `Point` 里仅存的两个数据成员。如果我们在某个时刻判断数据信息的具体数值的时候，我们可能会使用如下的写法：

```csharp
if (point.X == 30 && point.Y == 30)
    // ...
```

在 C# 里，我们只要写上一个自定义的解构函数，就可以对对象进行解构操作。我们写一个 `Deconstruct` 方法，然后带有两个参数：`x` 和 `y`，它们都是 `out int` 类型的。

```csharp
public void Deconstruct(out int x, out int y)
{
    x = X;
    y = Y;
}
```

通过这样的赋值后，我们就可以通过这个解构来完成数据的解构了：

```csharp
var point = new Point { X = 10, Y = 60 };

// Deconstruct.
var (x, y) = point;
```

当然，在模式匹配的时候，我们可以使用这样的代码对上面的写法进行简化：

```csharp
if (x == 30 && y == 30)
    // ...
```

不过，这样还不是很好看。因此 C# 还有这样的对位模式匹配：

```csharp
if (point is (x: 30, y: 30))
    // ...
```

通过一对小括号，我们可以实现对这个数据成员具体数值的检测。至于这里为什么是小写字母 `x` 和 `y`，是因为解构函数的参数分别是 `x` 和 `y`，这是一一对应的。正是因为如此，这个模式才叫做对位模式。其中，因为它借助了解构函数，而解构后的对象分配使用的是一对小括号（`var (x, y) = point;` 这个语句），因此为了配合这个写法，也用的是小括号。只是这里需要写出解构参数的名字。

稍微注意一点的是，C# 允许在同一个数据类型下定义多个解构函数，所以这正是为什么必须给出解构参数名称的原因。除非这个类型就这一个解构函数，那么我们都必须写出解构参数名。

#### 2、主构造器的对位模式

C# 9 和 C# 10 分别诞生了记录类型和记录结构类型，它们必须绑定一个主构造器位于声明的头部：

```csharp
record Person(string Name, int Age, bool IsBoy);
```

在使用模式匹配的时候，由于编译器会自动生成对应的解构函数，因此我们可以直接对主构造器使用对位模式匹配。

```csharp
if (person is Person(Name: "Sunnie", Age: 25, _)) ;
```

其中，小括号 `(Name: "Sunnie", Age: 25, _)` 左侧的数据类型类似于 `obj is T t` 的 `T`，而小括号书写出来的对位模式，则是 C# 允许的语法。它们甚至可以写在一起。当然，如果类型一样就不必判断类型了。

#### 3、调用扩展方法的对位模式

同时，编译器也能够嗅探扩展方法。换句话说，对位模式也允许扩展方法的解构函数。因此，C# 也允许调用扩展方法的解构函数来对位判断元素信息。

```csharp
static class Extensions
{
    public static void Deconstruct<T>(this T[] array, out T firstElement, out T secondElement)
    {
        firstElement = array[0];
        secondElement = array[1];
    }
}
```

于是我们可以使用这个方法对一个 `T[]` 进行解构：

```csharp
int[] arr = { 1, 3, 10 };
if (arr is (firstElement: 1, secondElement: var secondElement))
{
    Console.WriteLine(secondElement);
}
```

### 解构模式（Deconstruct Pattern）

#### 1、语法

因为前文我们拥有了解构函数，也拥有了 `var` 模式，因此 C# 灵活的语法提供了 `var` 模式的解构版本：

```csharp
if (point is var (x, y) && x == 30 && y == 30)
    // ...
```

稍微注意一下这里的语法是写成 `var (x, y)`。当然，你也可以内联 `var` 关键字。和值元组的语法一致，你依然可以用 `(var x, var y)` 的语法。

```csharp
if (point is (var x, var y) && x == 30 && y == 30)
    // ...
```

这样是可以的。

> 不过严谨一点的话，`var (x, y)` 是解构模式，而 `(var x, var y)` 是对位模式。因为前者使用 `var (x, y)` 语法，小括号里直接定义了变量名，小括号的外侧则是 `var` 关键字；但 `(var x, var y)` 在小括号里定义了两个变量，都使用了 `var` 关键字，这意味着是对应位置上的数据分别定义变量，类似 `point.X is var x && point.Y is var y` 的效果，因此只能说是对位模式。
>
> 使用解构模式可以更清楚、更简明地将对象进行解构，直接赋值到变量上；但它存在一定的弊端，例如解构模式下就不能往里判断数值了。也就是说，你在写成 `var (a, b)` 的类似语法后，就无法往 `a`、`b` 上使用任何模式匹配的判别语法了。该嵌套模式匹配之语法将在稍后说明。

#### 2、可空值类型解构模式的别样意义

在 C# 里，可空值类型一直是一种方便也不方便的数据类型。它的声明和使用都比较方便，但问题就出在它可能是 `null` 数值。假设前文的 `Point` 我们用的是可空类型的话：

```csharp
Point? nullable = new Point { X = 30, Y = 30 };
```

此时，我们在后续的代码里，无从根据代码直接确定 `nullable` 是否为 `null`（除非看取了 `nullable` 的值才行）。因此，一旦我们对这个类型进行解构：

```csharp
if (nullable is var (x, y))
    // ...
```

这就不单纯和 `var` 模式一样。它牵扯到数据是不是 `null` 才可解构的问题。如果数据都是 `null` 了，我们就无法解构。因此，可空值类型的解构模式会先判断对象是不是不为 `null`，然后才是解构。

```csharp
if (nullable != null && nullable.Value is (x: var x, y: var y))
    // ...
```

> `nullable != null` 和 `nullable.HasValue` 是等效的，所以写 `nullable.HasValue` 也没问题。

#### 3、主构造器的解构模式

是的，主构造器会自动生成对应的解构函数，因此完全可以直接使用解构模式。还是使用之前的 `Person` 类型：

```csharp
record Person(string Name, int Age, bool IsBoy);
```

那么，有这样的语法：

```csharp
if (person is var (name, _, isBoy)) ;
```

这样是允许的。但你不能写 `is Person (name, _, isBoy)`，因为前面的 `var` 关键字是这个模式匹配的固定格式，改成了 `Person` 的话，后面就只能看成对位模式了。

#### 4、调用扩展方法的解构模式

解构模式和对位模式类似，编译器也支持嗅探解构模式对应的扩展方法。一般正常的实现我们可能对一些数据类型无法实现解构操作，因此我们需要扩展方法来达到一些行为。比如假设我要去获取数组的前两个元素，我们经常会使用 `[0]` 和 `[1]` 来获取，不过现在我们可以使用解构模式来完成：

```csharp
static class Extensions
{
    public static void Deconstruct<T>(this T[] array, out T firstElement)
    {
        firstElement = array[0];
    }
}
```

假设我随便这么写了这个扩展方法，它们用于解构 `T[]` 数组。于是我们可以对一个一维数组进行解构操作：

```csharp
int[] arr = { 1, 3, 10 };
if (arr is var (firstElement))
{
    Console.WriteLine(firstElement);
}
```

请注意解构函数正常使用的时候是尽量不出现 0 或 1 个元素的解构模式，不过在这个时候也可能会遇到，因此语法没有对此进行限制。

#### 5、解构和对位模式不要求判断元素数量至少两个

这里稍微说一个比较不容易了解到的知识点。编译器限制我们定义一个至少两个元素的值元组 `ValueTuple` 类型，也就是说，一个或零个的值元组类型是不被允许的：

```csharp
var emptyTuple = (); // Wrong.
ValueTuple<int> singleElementTuple = (1); // Also wrong.
```

注意，第 2 行的代码我们假设写的 `var` 而不是 `ValueTuple<int>` 的话，编译器会自动消去 `(1)` 两侧的小括号，然后直接认为它是 1；故意显式给出类型名是为了告诉你，这两个情况都是值元组不被允许的。

不过，虽然解构模式和对位模式长得都跟值元组的类型声明模式很像，但对位模式和解构模式允许和支持解构函数可以包含任意多的 `out` 参数用于解构，这也意味着在解构模式和对位模式里，`is ()` 或 `is (1)` 是存在的语法。

#### 6、单元素的解构模式要手动消除二义性

在 C# 里，小括号如果不需要是会被编译器分析出来的。比如说 `var a = (1 + 3)`，此时的小括号没有必要需要它。在模式匹配里，单元素的解构模式也是一种特殊的处理：它会被视为常量模式，于是，考虑下面的例子，判断就有些奇怪了：

```csharp
var o = new C();
if (o is (42))
    // ...

class C
{
    public void Deconstruct(out int variable) => variable = 42;
}
```

请看这样的代码。你认为它是对的吗？答案是不对。编译器会首先认为 `(42)` 是常量模式，而 `o` 变量是 `C` 类型而不是一个整数，因此这个模式会导致编译器直接告知“永远都不会匹配成功”的编译器错误。

那么，怎么让它调用该解构函数来完成判别呢？答案其实很简单：消除编译器认为是常量模式的二义性即可。比如给 `(42)` 模式添加参数名。

```csharp
if (o is (variable: 42))
    // ...
```

这样编译器就不会简单认为是一个常量了。

#### 7、任意类型的解构模式

对任何数据类型（当然，指针类型除外）而言，我们都是可以使用解构模式的。这一点很神奇。

```csharp
object o = ...;
if (o is ())
    // ...
```

可，这会被视为什么判断规则呢？不知道你知不知道一个类型叫 `ITuple`？这个数据类型限制了类型具有元组的性质。所以，对任何数据类型来说的解构模式，实际上是被编译器特殊处理和优化过，并认为是在匹配该类型的数据规则。

比如 `o is ()` 会被视为 `o is ITuple tuple && tuple.Length == 0`。注意此时 `ITuple` 里的 `Length` 属性表示的是元组的元素数。当然了，如果你这个类型具有解构函数，就不会走这个路线去判断。但是，如果一个类型既没有实现这个 `ITuple` 接口，又没有匹配的解构函数，就会产生编译器错误。

### 弃元模式（Discard Pattern）

#### 1、语法

一旦解构后，我们就有办法只判断其中的一个数据。假设前文的解构函数存在的话，那么我们必然会解构成两个数据（`x` 和 `y`）。但是，如果我们仅判断 `x` 的数据，而不关心 `y` 是多少的话，我们可以使用一个下划线 `_` 来表示“`y` 我们不用判断”，或者说“`y` 的模式匹配总是成立的”。

```csharp
if (nullable is (x: 30, y: _))
    // ...
```

或者

```csharp
if (nullable is var (x, _) && x == 30)
    // ...
```

这么写都是可以的。

#### 2、弃元模式的叫法和定义范畴

呃，前面只要带有 `_` 记号（弃元符号）的地方，这些模式就都可以叫弃元模式。不论你这个 `var (_, _)` 也好，还是 `{ Length: _ }` 也好，还是 `T _` 也好，甚至包括稍后介绍的一些新语法也好，它们都是在一个大的模式匹配表达式里的其中一个模式匹配单元，它们都称为弃元模式，只要是用到了弃元符号 `_` 的地方。

### 类型模式（Type Pattern）

#### 1、语法

与其单独讲类型模式，还不如让你先明白，声明模式的那个类型，就是类型模式。

```csharp
if (list is int[] arr)
    // ...
```

所以，你干脆理解成这样：“声明模式 = 类型模式（就是这个类型）+ 变量定义”。但是，单独提出来说，是有原因的。

#### 2、不支持可空类型的类型模式

C# 8 开始拥有可空引用类型，而在 C# 2 开始则拥有可空值类型。这两种数据类型都带有 `?` 标记类型是可空的。不过，这些类型并不能使用到类型模式之中。

```csharp
if (obj is int? _) ;
if (obj is string? _) ;
```

这两种都是错误的。原因很简单：因为 `is` 是匹配类型，因此它必须得是这个类型。而既然都是这个类型的数据了，那么为何还去匹配一个可空类型呢？假设 `obj` 是 `int` 类型的数据，那么 `int is int?` 合理吗？显然不合理。`int is int` 才合理。那 `null is int?` 吗？`null` 是没数值的可空类型的默认数值，它不包含任何数值，因此 `is` 匹配它是没有意义的。

正是因为这些原因，你无法在 `is` 后使用和声明可空类型作为类型模式——因为是没有意义的。

#### 3、声明模式弃元

在 C# 里，`switch` 语句可以专门对一个不知道是什么类型的东西作模式匹配：

```csharp
switch (obj)
{
    case int[] arr: // ...
    case IEnumerable<int> enumerable: // ...
    case List<int> list: // ...
    default: // ...
}
```

这里，C# 也是允许的。可问题在于，`arr`、`enumerable` 等变量如果不用，我们无法去掉：C# 9 之前，这个变量是不可省去的：即使不用，你也得写弃元符号：`_`。

```csharp
switch (obj)
{
    case int[] _: // ...
    case IEnumerable<int> _: // ...
    case List<int> _: // ...
    default: // ...
}
```

不过，从 C# 9 开始，弃元符号就可以不写了。于是乎，模式匹配就可以简写成真正的类型模式了：

```csharp
switch (obj)
{
    case int[]: // ...
    case IEnumerable<int>: // ...
    case List<int>: // ...
    default: // ...
}
```

### 属性模式（Property Pattern）

#### 1、语法

属性模式是用于专门体现对象的属性信息的匹配模式。我们使用一对大括号来表达参数是否必须满足这个数值信息。

假如，我们现在的 `Point` 类型的 `X` 和 `Y` 不再使用字段表达，而是用属性来表达：

```csharp
public readonly struct Point
{
    public int X { get; }
    public int Y { get; }
}
```

那么，我们即使不给出解构函数，也可以使用属性的方式来对每一个成员信息进行判断：

```csharp
if (point is { X: 30, Y: 30 })
    // ...
```

属性模式专门给属性提供数据判断的服务，因此这种模式叫属性模式。

#### 2、属性模式的弃元

一般来说，属性模式下，由于不需要依赖于解构函数，因此属性是可以写出来判断的；反过来说，如果属性不判断的话，那么写出来就没意义了。不过 C# 的语法允许我们使用弃元来默认通过某个属性的判定：

```csharp
if (point is { X: 30, Y: _ })
    // ...
```

这样的话，`Y` 属性是永真式，即不用判断了。说白了，这里的 `Y: _` 是可以不写的。只是 C# 允许这种语法存在，体现出了语法的灵活性。

#### 3、空属性模式及变量声明内联

如果属性模式里的成员为空，那么它表示什么呢？

```csharp
if (nullable is { } point)
    // ...
```

是的，对于可空类型（不管是值类型也好，还是引用类型也好），都表示“不为 `null`”。比如 `nullable` 是一个可空的 `Point` 类型，那么 `is { }` 就表示 `nullable.HasValue`。当满足条件后，我们用 `point` 表示这个 `Point` 类型的数据。

从这个例子里，我们可以得到的若干信息是这些：

1. `is { }` 表示“不为 `null`”，适用于任何可为空的类型；
2. 大括号后可继续内联一个变量，和 `is T variable` 写法格式（声明模式）一致，但是，注意内联的这个变了和原始变量的类型和可空语义的不同：被匹配的变量（原始变量）是可空的，但是内联的后者这个变量是一定不空的。

> C# 是允许变量声明的内联作为模式匹配的一部分的。这里仅用空属性模式介绍了内联变量的写法，但你要知道的是，内联变量可用在任何情况下的属性模式。

#### 4、尽量不要让本来就不为 `null` 的表达式使用属性模式

可以发现，`is` 的左边其实可以为一个表达式。因此下面的代码是合法的：

```csharp
if (new Student("Sunnie", 25) is { } student)
    // ...
```

不过，这种写法具有副作用。`is` 的左边一定是一个不为 `null` 的表达式，那么我们就没有理由使用 `is { }` 来进行模式匹配。因为这样会导致编译器生成不必要的判空代码。

因此，为了避免这样的写法出现，我们可以改成 `var` 模式，或者是直接定义一个新的变量来进行赋值。

```csharp
// Way 1.
var student = new Student("Sunnie", 25);
// ...

// Way 2.
if (new Student("Sunnie", 25) is var student)
    // ...
```

请注意。这里所说的属性模式不单单只是空属性模式。在里面带别的属性使用 `var` 模式的话，也是不必要的写法。

```csharp
var student = new Student("Sunnie", 25);
if (student is { Name: var name, Age: var age })
    // ...
```

这种写法看似是在直接使用大括号语法来同时获取两个属性的数值，但是如果 `Student` 是引用类型的话，属性模式的大括号本身会让编译器自动生成判空代码，于是这样的代码等价于 `!ReferenceEquals(student, null) && student.Name is var name && student.Age is var age`。是的，它会做一次判断 `null` 的冗余操作。

如果你需要对多个这样的属性一齐取值的话，我建议你使用值元组来进行赋值：

```csharp
var (name, age) = (student.Name, student.Age);
```

用这样的语法来代替原来的写法。这样的赋值和原始的赋值的期望结果是一致的，但代码里也不会多出冗余的判空。

#### 5、可空值类型模式匹配是匹配的内部数值

判别对象是否为空，我们可以使用 `is null` 来完成，因此不空就使用 `!(obj is null)` 就可以了；与此同时，由于空属性模式也可以完成相同的行为，因此这样的代码也可以写成 `obj is { }`；对于可空值类型来说，我们还可以使用 `HasValue` 属性来完成：`obj.HasValue`。

但是，可空值类型在模式匹配里是当成值类型来假设的——它可能含有数值，那么数值直接拿出来即可；如果不含有数值，返回 `null` 就是判断模式的结果。而这里的 `HasValue` 是对所有可空值类型都具备的一个独特特性。但是在模式匹配里，你无法这么写代码：

```csharp
if (nullableValueObject is { HasValue: _ })
    // ...
```

比如属性模式，我们想要直接使用 `HasValue` 属性来完成属性模式匹配，这样的语法是错误的。因为编译器会假设 `nullableValueObject` 在模式匹配里是按数值进行判断的，即使它本身是可空值类型，但在模式匹配里它是被视为一个包含 `null` 的普通数值类型。比如说 `a` 是 `int?` 类型，那么 `a is { HasValue: _ }` 就是错误写法：因为 `a` 会被视为包含 `null` 的普通 `int` 类型，而不会被当成 `int?` 类型（即 `Nullable<int>` 类型）。这个意义在于，由于它进行模式匹配并不会被视为可空值类型，因此你无法使用 `{ HasValue: _ }` 类似的模式来获取其结果。

如果确实要获取可空值类型的内部数据，你应该写 `a is { } v` 或 `a.HasValue && a.Value is var v`，而不是 `a is { HasValue: _, Value: var v }`。

#### 6、用属性模式解构值类型对象

是的，C# 编译器确保了我们的操作完全只包含解构行为的时候，是可以不做判断即可使用这些变量的。举个例子。

```csharp
_ = stu is { Name: var name, Age: var age };
```

它不依赖于你的解构函数：只要对象具有该属性数值且包含 `get` 访问器可以用于取值操作，这个属性就可以用来作为属性模式解构操作的一部分。这种解构形式和之前学到的解构函数的解构模式不同，这里用的是属性模式的方式获取，因此称为**属性模式解构**（Property-pattern-styled Deconstruction）。

另外，上面用到了弃元符号。因为 `is` 表达式不可单独使用，它必须返回数值给变量调用。如果你确实不使用结果变量（实际上这个解构行为根本就不可能失败，所以上面这样的 `is` 表达式永远返回 `true`）赋值给等号左侧的话，只需要写弃元符号即可，它等价于这样：

```csharp
var name = stu.Name;
var age = stu.Age;
```

又或者是

```csharp
var (name, age) = (stu.Name, stu.Age);
```

等等写法。

另外，这样的解构风格允许你包含弃元模式嵌套在属性模式之中。但凡右侧 100% 是成功的解构操作的话，你怎么写模式匹配都可以：

```csharp
_ = obj is { A: _, B: { Nested: var nested, SecondNested: _ } _, C: var propCValue };
```

这些都是编译器允许的写法。这种就是带有递归使用的解构，它也是编译器允许的，因为这样的解构操作肯定是成功的。否则，由于可能失败，所以带有别的模式匹配的话，你可能就得用 `if` 来判断一下才知道是否模式匹配成功了。

```csharp
if (obj is { A: 10, B: { Nested: var nested, SecondNested: _ } _, C: var propCValue })
    // ...
```

这样的话，由于 `A` 属性判断了数值，所以可能解构操作不成功，这种场合你只能使用 `if`，而且不能简化成上面属性模式风格的解构的样式。顺带一说，`_ = a is pattern` 表达式的 `_` 不是模式匹配，它只是表示变量我们不使用了。

#### 7、递归模式Ⅰ：属性模式递归

C# 强大的地方在于，语法很灵活，这样我们写代码可以不用唯一的一条道路去实现。比如前面的解构模式。`(x: var x, y: var y)` 里又是一个 `var` 模式的变量声明。所以，正是因为这样，我们学 C# 就不必学得那么痛苦。

C# 的属性模式是 C# 一大秀儿语法。它允许递归使用属性模式进行判断。假设我有这么一个对象：

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Gender Gender { get; set; }
    public Person? Father { get; set; }
    public Person? Mother { get; set; }
}
```

这个对象是表示一个人的基本数据信息，比如名字啊、年龄啥的，当然也存储了 ta 的父母的实例的引用。

> 其中，我们假设 `Gender` 类型是个暂时只包含 `Male` 和 `Female` 俩字段的枚举类型。
>
> `Person?` 语法表示 `Person` 这个引用类型具有和值类型类似的语法：这个属性信息可为 `null`。反之，如果没有 `?` 标记的类型，这个成员的数值就不能为 `null`。这个语法是 C# 8 里的，这里为了体现出判断用法，故意写上了 `?` 来表达为 `null`、更显眼一点；另外，这里故意取可为 `null` 的写法，还有一个目的，是为了体现一会儿模式匹配的语义，所以请不要和现实世界进行对比或者对号入座。

假如，我们要判断是否某个人的姓名是“张三”、年龄 24，他爸叫“张二”、而他的妈妈则叫“李四”。如果要判断这个对象的具体信息，我们可以这么写代码：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father: { Name: "Zhang 'er" },
        Mother: { Name: "Li si" }
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

注意这里的模式匹配写法。前面模式匹配就用的是大括号，因此我们可以对对象的内部信息继续作判断。比如 `Father` 和 `Mother` 属性又是一个 `Person` 类型的对象，因此我们还可以接续一个大括号对 `Father` 和 `Mother` 的值的具体内容继续进行判断。

一定要注意。`Father` 和 `Mother` 属性是可能为 `null` 的。当 `Father` 属性的数值本身就是 `null` 的时候，那么显然就不存在 `Name: "Zhang 'er"` 的判断行为了：因为 `null` 值本身就无法继续判断内部数据了。因此，在 `Father` 为 `null` 的时候，模式匹配结果一定是 `false`。当且仅当整个判断的逻辑全都匹配，`if` 条件才成立。

顺带给大家看下，C# 的模式匹配到底多有魅力：给大家展示一个我之前写过的一段代码，用到了这里的模式匹配。

```csharp
if (
    node is
    {
        Expression: MemberAccessExpressionSyntax
        {
            RawKind: (int)SyntaxKind.SimpleMemberAccessExpression,
            Expression: MemberAccessExpressionSyntax
            {
                RawKind: (int)SyntaxKind.SimpleMemberAccessExpression,
                Expression: IdentifierNameSyntax
                {
                    Identifier: { ValueText: "TextResources" }
                },
                Name: IdentifierNameSyntax
                {
                    Identifier: { ValueText: "Current" }
                }
            },
            Name: IdentifierNameSyntax
            {
                Identifier: { ValueText: var methodName }
            } nameNode
        },
        ArgumentList: var argList
    }
)
{
    // ...
}
```

这里，这么一大坨都是递归的模式匹配。正好这体现出了模式匹配的魅力。

#### 8、递归模式Ⅱ：对位模式和属性模式是可以放在一起的

C# 的属性模式具有和对位模式完全一致的判断行为，因此 C# 就把对位模式和属性模式在语义分析上放在了一起。假设我有一个 `Point` 类型，包含 `X` 和 `Y` 属性（它们通过解构函数解构为 `x` 和 `y` 两个参数），并且包含 `Area` 属性表示当前点到坐标原点构成的矩形的面积。

这里不是讲数学，我只是告诉你如何并用两个模式。

```csharp
if (point is (x: 10, y: 30) { Area: _ }) ;
```

可以看到，我们直接在 `(x: 10, y: 30)` 这个对位模式后加上了 `{ Area: _ }` 属性模式。在 C# 里，对位模式和属性模式均可以用于递归使用（比如假设一个对位模式的成员是可以继续通过别的模式进行匹配的，那么这个成员就可以继续递归地进行模式的判断），同时属性模式也是如此，前文已经说过了。因此，C# 把对位模式和属性模式统称**递归模式**（Recursive Pattern）。换句话说，在概念上来讲，你可以同时使用对位模式和属性模式的两种不同模式的判别，并放在一起，这个整体叫做递归模式。

但请注意，必须是先对位模式，后属性模式的顺序。写反了是不行的。

### 关系模式（Relational Pattern）

#### 1、语法

前面的模式可以解决一大部分的问题了，但是有些时候，数据判断和取值无法对一个范围来判断，因此还不够灵活。C# 里还有关系模式，来对数据的范围来判断。

```csharp
if (obj is > 30)
    // ...
```

即使 `obj` 不是 `int` 类型，我们依旧可以这么写。这个代码等价于 `obj is int i && i > 30`。

C# 允许 `>`、`>=`、`<` 和 `<=` 四个运算符，写在 `is` 后，来表达范围判断。稍微注意一下的地方是，`is > 30` 的 30 必须是常量才行。

给大家看一个例子：

```csharp
Console.WriteLine(Classify(13)); // output: Too high
Console.WriteLine(Classify(double.NaN)); // output: Unknown
Console.WriteLine(Classify(2.4)); // output: Acceptable

static string Classify(double measurement) => measurement switch
{
    < -4.0 => "Too low",
    > 10.0 => "Too high",
    double.NaN => "Unknown",
    _ => "Acceptable",
};
```

不过怎么理解，就靠你自己了。

#### 2、不推断类型的时候，不要用模式匹配

正是因为出了这个模式，下面两句话就变成等价的了：

```csharp
int v = 30;

bool condition1 = v > 30;
bool condition2 = v is > 30;
```

显然，要不要 `is`，语句都可以理解。但是，有 `is` 需要模式匹配，因此显然复杂一点。因此，我们建议在数据类型不用判断的时候，不要使用 `is`。当然，这里说的结论指的是这里这种情况。

### 逻辑模式（Logical Pattern）

因为模式匹配里的每个模式并不是一个“数据信息”，因此我们无法直接对模式用 `&&`、`||` 等符号来进行拼接组合。C# 为了解决这个问题，多了三个关键字：`and`、`or` 和 `not` 来拼接模式。

#### 1、合取模式

合取模式用 `and` 拼接模式，来表达这些模式都必须成立。

```csharp
static bool IsLowerLetter(char c) => c is >= 'a' and <= 'z';
```

比如这里，`>= 'a' and <= 'z'` 整个表达式用来表达，`>= 'a'` 和 `<= 'z'` 两个条件必须都满足。如果要写分开，就必须写成 `c is >= 'a' && c is <= 'z'`。

#### 2、析取模式

析取模式用 `or` 拼接。

```csharp
static bool IsLetter(char c) => c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z');
```

注意，`or` 拼接了前面 `>= 'a' and <= 'z'` 和后面 `>= 'A' and <= 'Z'` 两个模式。`or` 表示两个模式有一个模式能够匹配成功就可以。

#### 3、取反模式

取反模式用 `not`。

```csharp
if (input is not null)
    // ...
```

最常见的就是这里。我们如果判断对象是不是不为 `null`，那么我们最常用的就是写成 `is not null`。`is null` 属于前面的常量模式，判断对象是不是 `null`。它和 `==` 运算符的区别是，`==` 运算符可重载，重载会影响 `==` 的判断和使用逻辑；而 `is` 是永远不变的判断模式。

#### 4、混用析取、合取和取反

当然，你也可以混用到 `and` 和 `or` 关键字拼接起来的模式里。

```csharp
if (ch is >= '0' and <= '9' or '.')
    // ...
```

这表示 `ch` 是不是字符 0 到 9，或者是小数点。将其取反：

```csharp
if (ch is not (>= '0' and <= '9' or '.'))
    // ...
```

这就表示取反。当然了，你可以使用类似数学知识，将 `not` 套到小括号里：

```csharp
if (ch is not (>= '0' and <= '9' or '.')) ;
if (ch is not ((>= '0' and <= '9') or '.')) ;
if (ch is not (>= '0' and <= '9') and not '.') ;
if (ch is (not >= '0' or not <= '9') and not '.') ;
```

这 4 行内容可以帮助你理解和拼接模式的具体内容。

#### 5、合取式、析取式和取反式的优先级

稍微注意一下。合取式 `and` 和数学上是一样的，比 `or` 更优先推理，因此无需对 `and` 和 `or` 模式一起的复杂模式匹配添加括号：

```csharp
static bool IsLetter(char c) => c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z');
```

比如这样，`(>= 'a' and <= 'z')` 和 `(>= 'A' and <= 'Z')` 的小括号可以不要。

取反式的话，因为它只和一个模式结合使用，不像是 `and` 和 `or` 需要两个模式结合，因此 `not` 的优先级比 `and` 和 `not` 都要高。所以，上面的例子里，这个写法你应该是知道哪些地方省略了小括号。

```csharp
if (ch is (not >= '0' or not <= '9') and not '.') ;
```

#### 6、字面量在 `and` 模式表示其类型的上下文之中变动本身的类型

之所以放在这里说，是因为字面量是可以进行类型匹配的，这也就是前文提到的常量模式。不过，字面量有时候表现得并不一定非得是字面量本身的数据类型。

举个例子，1 是 `int` 类型的字面量，但我们可以使用 `and` 连接常量模式和类型模式，使得这个 1 的类型发生变化：

```csharp
object o = 1U;
if (o is uint and 1)
    // ...
```

请注意这里的 `uint and 1` 模式。`uint` 是表示类型必须是 `uint` 类型，而 1 却又是 `int` 类型的字面量，这不会冲突吗？答案是并不会，字面量在模式匹配里会按照 `and` 里联立给出的类型进行隐式转换。如果能够转换过去，那么就是允许的。

举个例子，`o is decimal and 1` 和 `o is decimal and 1M` 是一个意思，这个字面量 `1` 可以写成 `1M` 但也可以直接写成 `1`，因为字面量会按照类型匹配的关系自动转换其表达的类型。不过，这仅限于上下文可以暗示类型的情况。如果前面用的是 `or` 的话，就不行了。

```csharp
object o = 1U;
if (o is uint or 1)
    // ...
```

这表示什么呢？这表示 `o is uint || o is 1`，也就是 `o is uint || o is int && (int)o == 1` 的意思。

#### 7、`is not var` 组合模式到底是否为永假式？

所谓的永真和永假式，就是说这个式子的判断结果永远都是 `true` 或 `false`。比如 `if (true)` 条件我们直接写的是 `true` 字面量，这就是一种典型的永真式；当然你不嫌复杂也可以写 `if (!false && true || false || true)` 这种超级复杂的写法。

那么，`expr is var variable` 的话，假设 `expr` 是一个表达式的话，那么它是否是永真式呢？

这个问题问得好。`expr is var variable` 的模式匹配规则允许我们将表达式的结果在内联为布尔运算逻辑的其中当成一个永真的表达式在使用，目的是为了合并多个布尔表达式，使之直接称为一个表达式还能跑起来，这样就可以不用使用一大堆的 `if` 判断语句来影响可读性和代码量了。

不过，`is var` 真的是永真的吗？如果是的话，那么 `is not var` 不就是永假式么？永假的逻辑在 `if` 里还不如就写成 `if (false)` 么？那这种东西还有何意义呢？

实际上，并非如此。`is var` 也不一定随时都永真。考虑一种情况：解构模式。解构模式需要我们按照一定的情况对一个对象进行解构。它需要对象有一个解构函数，或者是包含一个可访问到的扩展解构函数。

考虑一种情况，假设这个对象是引用类型呢？那么解构会随时都成功吗？不见得，对吧，因为它自己可能是 `null`。因此，在引用类型使用该模式组合的时候是有别的含义的，比如：

```csharp
var nullableExpression = ...;
if (nullableExpression is not var (_, secondVariable, thirdVariable))
    return;

// Here can use 'secondVariable' and 'thirdVariable'.
// ...
```

对于这种情况下，`nullableExpression` 在判断的意思就是，如果它不可解构为后面的三个变量的时候，则退出方法。在这个时候，“不可解构”就对应了它为 `null` 的时候。

不过，对于纯定义变量的 `is var` 的话，它肯定是直接赋值过去的，它根本不判空。因此，`is not var` 不可用于这种情况：因为它永假，导致的情况就是无法完成匹配，因此 `var` 后面的变量你写啥都没有用：反正也不会成功赋值过去。因此后续的变量自然就不可能用得上它，因此编译器也不允许你这么写代码。

#### 8、纯弃元不可单独使用

前文简要介绍过弃元模式的用法和范畴，不过弃元模式是可以直接运用到逻辑模式里的：

```csharp
if (o is var _ and _ and _)
    // ...
```

只要在模式匹配期间出现了一个 `var _` 或者别的什么模式，就可以直接使用纯弃元 `_`。当然，这么写没有意义，因为是冗余的模式匹配（它什么都没有判定），只是说可以这么用——编译器认为不是错误的语法，就没有必要去限制它。

### 拓展属性模式（Extended Property Pattern）

#### 1、语法

因为属性模式本身有些地方很鸡肋，因为它可以嵌套，比如下面这样的代码：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father: { Name: "Zhang 'er" },
        Mother: { Name: "Li si" }
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

这是之前的属性递归介绍的代码。这个写法里，`Father` 里再次包含一层大括号。

在新的模式匹配里，为了解决这种大括号嵌套太多层次导致可读性降低的问题，发明了拓展属性模式。拓展属性模式允许将这个代码简写为 `Father.Name`：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father.Name: "Zhang 'er",
        Mother.Name: "Li si"
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

即少一个大括号的层级级别：`Prop: { NestProp: { } }` 改成 `Prop.NestedProp { }` 的格式。

#### 2、成员访问运算符的隐式判空

请注意，两种写法是等价的。可能你会认为前者的大括号的层次会让判断逻辑多一次 `null` 的判断：`Prop is not null && Prop.NestedProp is not null`，而 `Prop.NestedProp { }` 这个写法因为 `Prop` 和 `NestedProp` 是直接引用的（用小数点关联起来），所以不会这么做。如果你这么想的话，那你就错了。C# 的拓展属性模式仅仅是为了简化代码才这么写代码的。这里的小数点（成员访问运算符）和我们以前学习的标准的成员访问运算符是不一致的语义：这里只能表示逻辑上的引用的层次关系，而一旦发现 `Prop` 是可空类型的话，那么访问 `NestedProp` 这个嵌套属性的时候就会必然先对外层的 `Prop` 属性数值做一次隐式判空，避免直接访问 `NestedProp` 而产生异常。

另一方面，正是因为编译器会自动隐式产生判空的情况，所以 C# 语法上不允许我们在这个小数点前面加 `?`，即比如 `Prop?.NestedProp: { }`，这么写是错误的语法。假设你想要实现类似的行为，请必须使用 `null or` 模式：

```csharp
Father: null or { Name: "Zhang 'er" }

// Or double negation.
Father: not { Name: not "Zhang 'er" }
```

来代替错误的语法：

```csharp
Father?.Name: "Zhang 'er"
```

### 列表模式（List Pattern）

#### 1、语法

为了将集合的元素提取出来判断，C# 拥有了列表模式。

列表模式是将一个不知道是不是集合的对象，用列表的格式列举出来，对其中的元素挨个进行判断的模式。

我们使用一对大括号进行判断。使用范围记号 `..` 来表达“这是一个范围”。举个例子：`[1, .., 3]` 表示判断一个序列的第一个元素是不是 1，而最后一个元素是不是 3。所以，自然这个写法就等价于下面这个格式了：

```csharp
if (arr is { Length: 10 } and [1, .., 3])
    // ...
```

它等价于

```csharp
if (arr.Length == 10 && arr[0] == 1 && arr[^1] == 3)
    // ...
```

这里的 `^1` 是 C# 8 里的表达式，表示倒数第一个元素。`^n` 就是倒数第 n 个元素。可以从这个写法里看出，`..` 是灵活的：它不是固定长度，是随着整个模式匹配的序列来确定 `..` 的长度的。这么写是为了简化代码的书写格式。

当然，假设我们判断倒数第二个元素而不是倒数第一个的话，那么我们可以尝试在倒数第一个元素的判断信息上添加弃元记号 `_` 来表达占位：

```csharp
if (arr is { Length: 10 } and [1, .., 3, _])
    // ...
```

弃元记号在这里起到了很重要的作用。一个弃元记号占一个位置，这恰好表达和判断了 `arr[^2]` 的数据，而不是 `arr[^1]`。

#### 2、预防性长度判断

和前文一致，要用这个模式的话，这个数据类型除了拥有 `Length` 或 `Count` 属性外，索引器成员是必不可少的。另外，如果你不写上范围记号 `..` 的话，就成了判断恰好这些数据了。

```csharp
if (arr is { Length: 10 } and [1, 2, 4])
    // ...
if (arr is { Length: 10 } and [1, 2, 4, ..])
    // ...
if (arr is [1, 2, 4])
    // ...
```

这三个写法的区别是，第一个和第二个是一样的判断：因为 `[1, 2, 4]` 按照顺序，判断的都是前三个数据的数值，因此长度给出后，判断的自然是前三个数据了，而后续的数据不用管，写上 `..` 和不写 `..` 都是没有关系的。但是第三个则不一样了。第三个因为长度模式不存在的关系，模式匹配的长度模式会依赖于 `[1, 2, 4]` 这个列表模式。这个模式只给出了三个元素，因此不写长度模式的话，编译器会认为这个写法下，长度模式是 `{ Length: 3 }`；相反，如果你加上了 `..` 的话，编译器就不再去确认后面的元素信息了。

但是，为了避免抛出异常，C# 会贴心地做一个“预防性判断”。如果 `arr` 没有这么长呢？假设 `arr` 就俩元素，那么判断 `[1, 2, 4, .. ]` 就可能产生一个异常。因此，C# 会自动生成一条预判长度语句：`arr.Length >= 3`。

因此，如下四种写法的等价格式是这样的：

| 语法                                      | 等价判断                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| `arr is { Length: 10 } and [1, 2, 4]`     | `arr.Length == 10 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is { Length: 10 } and [1, 2, 4, ..]` | `arr.Length == 10 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is [1, 2, 4]`                        | `arr.Length == 3 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is [1, 2, 4, ..]`                    | `arr.Length >= 3 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |

“默认生成预防性长度判断”这一点比较隐晦，因此你一定要记住。

#### 3、注意使用条件

在列表模式里，我们约定数据类型必须包含索引器和 `Count` 或 `Length` 属性才可以使用列表模式，下面有两个最容易忽略也会被当成可以用列表模式，实际上不然的数据类型。

1. `Dictionary<TKey, TValue>` 类型；
2. `ICollection<T>` 类型。

首先，字典数据类型的索引器并不是 `int` 数据类型，而是 `TKey` 这个泛型数据类型的。由于 C# 对列表模式的语法设计规则，所以字典无法表达出合适的写法，所以字典类型不支持列表模式；同时，`ICollection<T>` 类型也不支持。原因可能让人大跌眼镜：这个接口压根就没有索引器的成员。可能这一点非常容易忽略掉，但是也很好想到为什么：实现了 `ICollection<T>` 接口的数据类型我们都可以叫它们“集合”。但集合只表示和表达一种合适的存储序列。但序列不一定是连续的，也就是说，你不一定可以使用这个集合类型从前一个元素来找后一个元素。最常见的情况就是“不重复集合”。如果你写了一个不重复集合的话，它可能会使用哈希码来建立列表。那么元素之间就不一定是连续的了，因此你无法定义一种良好的索引机制获取每一个元素。这样的数据类型就不存在索引器一说。正是因为存在这样的集合数据类型不含有索引器，因此你无法对一个这样的数据类型使用列表模式，因为列表模式依赖索引器机制。

#### 4、无条件成立的列表模式

当然，既然可以允许判断列表模式，那么自然就有 `[..]` 这种写法。这个写法的意思是，集合的元素无条件成立。但是，这个写法还不如不写，对吧。

#### 5、请一定注意，列表模式不是递归模式的一部分

如题，列表模式是一个单独的模式，你必须声明得和别的模式串联起来用 `and` 或 `or` 连接，所以如下的语法是错的：

```csharp
if (o is int[] [1, _, .., 3])
    // ...
```

正确的做法是在 `int[]` 和 `[1, _, .., 3]` 之间插入一个 `and`：

```csharp
if (o is int[] and [1, _, .., 3])
    // ...
```

这一点一定要记住，因为它是对集合作判断，但大多数类型也都不是集合，因此不要想着把它和别的模式放在一起；但是，列表模式允许定义内联变量。

```csharp
if (expr is [_, _, ..] result)
    // ...
```

假设此时的 `expr` 是一个表达式，我们可以使用此语法定义表达结果，并视 `result` 为表达式的运算结果。

还有一个原因是，假设我们想要确定是否一个数据类型是 `int[]` 并且没有元素的话，它的语法是 `is int[] and []`。如果我们去掉 `and` 使之允许，这个语法就成了 `is int[] []`，这会被编译器视为 `is int[][]`，即判断对象是不是一个元素是 `int` 的锯齿数组。因此，不加 `and` 还真不行。

### 分片模式（Slice Pattern）

#### 1、语法

C# 允许对集合类型的分片。举个例子。

```csharp
if (arr is { Length: 10 } and [_, .. var slice, _])
    // ...
```

这段代码表示，我们将中间的 8 个元素提取出来，变成一个列表。它等价于这个写法：

```csharp
if (arr.Length == 10 && arr[1..^1] is var slice)
    // ...
```

一定要注意，`1..^1` 的语义是“取` [1]` 到 `[^2]` 的元素，而绝对不是取到 `^1`。因为 C# 的范围表达式是取前不取后的（前闭后开的半开区间）。

#### 2、分片模式的弃元

分片模式也支持弃元。换句话说，我们可以在 `..` 后跟上 `_` 来表示这一截内容我们不参与模式匹配，它和不写弃元符号的时候匹配的内容是完全一致的，只是为了确保语法的灵活性：

```csharp
if (arr is [1, 2, .. _, 3, 4])
    // ...
```

这里的 `.. _` 的 `_` 就是弃元用法。不过它没有意义，可以省略。

#### 3、分片模式解构及嵌套模式匹配

分片模式允许我们对范围记号 `..` 的内容进行内联变量定义，但这样的代码仍不够灵活。我还想要内联模式匹配的话，C# 是提供了这个机制的。看看这样的代码是什么意思？

```csharp
if (arr is [_, _, .. [_, .., 7], _])
    // ...
```

是的，在模式匹配 `[_, _, .. [_, .., 7], _]` 的模式。这个模式要求我们列表集合里至少含有三个以上的元素。接着，`.. [_, .., 7]` 是分片模式的嵌套模式匹配。我们从第三个元素开始判断，我们必须要求从第三个元素开始，我们包含一个序列，它至少有两个元素，且最后一个元素是 7。换句话说，它等价于这样的代码：

```csharp
if (arr is { Length: >= 3 } && arr[2..^1] is { Length: >= 2 } sliced && sliced[^1] == 7)
    // ...
```

注意这里的判断模式。我们用到了三个逻辑表达式，且使用 `&&` 运算符连起来。下面来说一下挨个的具体判断内容。

* 第一个表达式 `arr is { Length: >= 3 }` 判断整个数组是不是不为 `null` 的同时还至少包含 3 个元素。注意这里 `arr` 虽然显然不空，但编译器会自动确保引用类型不空而自动产生该 `is not null` 的模式匹配代码；
* 第二个表达式 `arr[2..^1] is { Length: >= 2 } sliced` 较为复杂。它先获取 `arr` 从第 2 索引元素（第 3 个元素）到倒数第二个元素（一定注意索引运算符是取前不取后的）。这个操作如果获取成功，则返回正常数组，否则会返回 `null`。因此这个 `is { Length: >= 2 }` 验证了 `arr[2..^1]` 是否在取分片数组的时候返回结果是否不为 `null`。如果不为空还要判断它的长度是不是至少包含 2 个元素。接着，如果两个判断逻辑都成功的话，那么 `sliced` 变量就可以使用了，它就是这个分片后的数组结果；
* 第三个表达式 `sliced[^1] == 7` 就是获取整个数组的最后一个元素，看看是不是 7。

所以整个表达式稍显复杂，但按顺序来看的话，就不会有任何问题了。

#### 4、列表和分片模式的范围记号 `..` 最多只能有一个

虽然有些时候我们很想写这样的代码：

```csharp
if (arr is [.., 40, ..]) // Ah?
    // ...
```

我们的想法是，元素至少有一个，且整个序列里至少有一个元素的结果是 40。

可，C# 编译器并不理解这样的语法，它认为 `..` 的长度不定，因此无法叠加使用，否则将无法确保使用的严谨性，比如这样的代码：

```csharp
if (arr is [.., 10, 20, ..]) // Hmmm...
    // ...
```

这个 `[.., 10, 20, ..]` 就无法理解。而且，这样的代码也是没有意义的：

```csharp
if (arr is [.., .., _]) // Also wrong.
    // ...
```

连续使用两个范围记号 `..`。因此，请一定记住，列表和分片模式的范围记号最多只能有一个。不过，这种不影响：

```csharp
if (arr is [.. [.., _], _]) // Correct.
    // ...
```

这种是分片之后判断序列的模式是 `[.., _]`，因此这个是可以的，因为不会冲突。

#### 5、分片模式里的模式嵌套

如果这个数组的每一个元素并不是简单的类型，那么它里面可能包含一些别的元素。这个时候我们可能会在分片后，使用别的模式进行模式匹配：

```csharp
if (nestedArr is [_, .. [{ Prop: 42 } sliced, ..], _])
    // ...
```

比如这里 `.. [{ Prop: 42 } sliced, ..]` 就是一个典型的嵌套用法。`..` 后跟上 `[{ Prop: 42 } sliced, ..]` 是一个嵌套进去的分片模式。其中，它判断分片后的序列至少包含 1 个元素，且第一个元素必须满足模式 `{ Prop: 42 } sliced`，也就是 `Prop` 属性必须是 42。如果成功匹配，那么这个元素名称可以使用 `sliced` 标识符引用。

### 模模式（Cardinality Pattern）

模模式其实就是我们之前的 `{ Length: _ }` 或者 `{ Count: _ }`。这个其实就是属性模式的一种特例——属性名恰好是 `Length` 或 `Count` 而已，只是在 C# 11 里单独为这两个特殊的属性模式匹配的逻辑有所加强：它的代码内容会影响编译器分析代码。

> 模模式的原名叫**长度模式**（Length Pattern），不过在模式匹配里，C# 定义了 `Length` 和 `Count` 可以提供和参与编译器分析非负性的属性名称，length 这个单词可以叫长度，但 count 不能。因为 count 记录的是元素总个数，你只能说集合有多少元素，而不能说集合长度是多少。从定义和名称叫法上 count 和 length 有区别，所以本文改了一个说法。这个模模式的模就是长度的意思，而它恰好就具有两种不同类型 length 和 count 都可涵盖的含义，所以本文介绍的时候将其称为模模式。其中英语术语里的 cardinality 是基数的意思，指的是集合里有多少个元素；不过在计算机科学范畴，cardinality 除了翻译成基数以外，还可以被翻译为“势”。比如说两个集合等势就意味着两个集合的元素是一一对应起来的。这里用不着这么复杂的概念，我们只需要知道它的基本用法表元素总数就可以了。
>
> 不过，如果你在查资料的时候请仍然按照“长度模式”这个术语去查阅，只是本文为了避免二义性和语义冲突而换了一个说法。

早期的长度模式只是一个简单的属性判断，但在 C# 11 里有了列表模式和分片模式，因此在集合里，长度的分析过程变得非常重要。

#### 1、系统类型的长度属性均假设为非负数

C# 11 开始，系统提供的集合类型里，只要它带有 `Length` 或 `Count` 属性的话，那么编译器会自动假设它非负。换句话说，虽然我们大家都知道，`Length` 和 `Count` 属性返回值是 `int`，它有负整数的范围，但集合的元素总数是不可能为负数的（哪怕是空集合，长度也是 0，也并非负数）。因此，系统会假设这些数据类型（特别是一维数组类型需要注意）一定是非负长度。如果你使用如下代码，编译器会自动报错：

```csharp
if (arr is { Length: -1 })
    // ...
```

并提示你，数组的长度非负，因此这个属性模式将永远不会匹配成功。

#### 2、自定义类型的长度模式对编译器的表现行为

这里说一下编译器的处理机制。不论是你定义的集合类型，还是系统给定的数据类型里，长度的非负性质一直是一个正常的逻辑实现。虽然你可以随意给 `Length` 或 `Count` 属性设置为一个负数值，但它并不是正确的实现，因为长度在使用的时候一定是非负的，虽然它的返回值是 `int` 类型包含负数的数值范围。

使用 `int` 类型但不允许非负的原因是因为，`uint` 类型虽然能够保证非负，但它不符合 CLS（公共语言运行时）的标准，也就是说，这样的代码可能只能在 C# 上跑，而同一个 DLL 文件编译出来之后，VB 对这个 `uint` 不支持，因此无法使用这样的代码。因此为了兼容性，我们设置了 `int` 作为理想的返回类型。

而编译器会先查看这个数据类型是否同时包含一个索引器和一个 `Length` 或 `Count` 属性。如果同时存在，那么既然你都能索引了，这个类型的长度就一定不可为负数。但是，如果你没有索引器，但只包含一个单纯的 `Length` 或 `Count` 属性的话，编译器会认为它是普通的属性，因此不会验证负数情况。

所以总的来说，必须同时包含索引器和长度属性（`Length` 或 `Count` 其一）的时候，编译器才会假设长度属性的结果一定非负。

#### 3、同时包含 `Length` 和 `Count` 属性的时候

如果一个集合同时包含 `Length` 和 `Count` 属性的话，C# 团队的解决办法是，只验证其中的 `Length` 属性一定非负，而 `Count` 属性就不再会假设为非负的情况。举个例子。

```csharp
_ = list is { Count: -1 };
_ = list is { Length: -1 };
```

如果同时有这两个语句，那么只有 `Length` 属性会得到非负数的假设。而 `Count` 属性不论什么时候也不会被假设为非负的，因此这段代码里，如果 `list` 满足这个模式的判断条件（带索引器，同时带有两种长度属性）的话，那么报错信息只会出在第二行上，第一行是没有任何错误信息的。

### `ReadOnlySpan<char>` 模式（`ReadOnlySpan<char>` Pattern）

从 C# 11 开始，`ReadOnlySpan<char>` 类型的实例将可以使用模式匹配来判断内部存储的字符串信息。

#### 1、语法

要知道，`ReadOnlySpan<T>` 类型是一个非常轻量级的存储集合，它类似于数组，但数组是引用类型，该类型是值类型。它可以接收很多类型的实例作为存储信息，当然，也包含 `char`。因此，C# 对这个类型有特殊处理：如果是 `ReadOnlySpan<char>` 的话，那么可以接收字符串来赋值：

```csharp
ReadOnlySpan<char> strSpan = "Hello, world!";
```

而 C# 11 开始，我们支持该类型使用字符串的模式匹配规则来匹配该类型的对象。

```csharp
switch (strSpan)
{
    case "Hello":
        // ...
        break;
    case "world":
        // ...
        break;
    case "Hello, world":
        // ...
        break;
}
```

比如这么使用。

#### 2、`null` 对于 `ReadOnlySpan<char>` 的奇怪表现

请一定要注意，`ReadOnlySpan<char>` 是值类型，但你仍然可以赋个 `null` 过去：

```csharp
ReadOnlySpan<char> s = null;
```

这是被允许的。原因是 `null` 在这里是 `char[]?` 类型的对象，而对于 `ReadOnlySpan<char>`，是有一个隐式转换的，签名长这样：

```csharp
public static implicit operator ReadOnlySpan<char>(char[]? array);
```

因此你可以这么做。但是，由于赋值之后的 `s` 对象是值类型，因此你不能对 `ReadOnlySpan<char>` 类型的实例使用 `null` 常量模式匹配：

```csharp
if (s is null)
    // ...
```

这样是错误的。因为模式匹配（尤其是关于 `null` 的常量模式），编译器是不知道你这个隐式转换的。这里的 `s` 是值类型 `ReadOnlySpan<char>` 类型的变量，而它既然是值类型，就永远不可能为 `null`。因此，`is null` 将永远返回 `false`。所以，这么使用是不合适的。

## 综合

下面我们来讨论一些关于前面讲解的模式匹配的综合内容。

### 1、如何判断集合至少有一个元素

如下的这些模式都可以。

```csharp
int[] arr = { 2, 3, 5, 7 };

// List pattern (Sorted by code length).
if (arr is not (not { } or []))        Console.WriteLine(arr[0]);
if (arr is { Length: not 0 })          Console.WriteLine(arr[0]);
if (arr is not (null or []))           Console.WriteLine(arr[0]);
if (arr is { Length: > 0 })            Console.WriteLine(arr[0]);
if (arr is { } and not [])             Console.WriteLine(arr[0]);
if (arr is [.., _])                    Console.WriteLine(arr[0]);
if (arr is [_, ..])                    Console.WriteLine(arr[0]);

// Slice.
if (arr is [var f, ..])                Console.WriteLine(f);

// Pure check.
if (arr != null && arr.Length != 0)    Console.WriteLine(arr[0]);
if ((arr?.Length ?? -1) != 0)          Console.WriteLine(arr[0]);
```

* **`not (not { } or [])`**：先看内层 `not { } or []`，它表示要么 `not { }`，要么 `[]`。`not { }` 等于 `is null`，而 `[]` 等于 `Length == 0` 属性判断，所以对整个模式取反 `not (not { } or [])` 就是 `not (null or { Length: 0 })`，即不空且至少包含一个元素；
* **`{ Length: not 0 }`**：最基础的属性模式判断。不过这个用法稍微注意一下，如果集合不含 `Length` 属性而是 `Count` 属性，你可能需要改掉这里的 `Length` 名称；
* **`not (null or [])`**：`not { }` 就是 `null`，所以和第一个写法等价；
* **`{ Length: > 0 }`**：和第二个一致，只不过这里是要求 `Length` 必须非负。但是 C# 11 开始模模式必须非负，因此语义上 `> 0` 和 `not 0` 是一致的了；
* **`{ } and not []`**：`{ }` 是 `not null`，`not []` 则是 `Length == 0` 的属性判断，因此结合起来就是序列不空，且至少有一个元素；
* **`[.., _]`** 和 **`[_, ..]`**：这两个写法是等价的，不必多说——列表模式包含一个弃元符号和范围记号，因此序列至少包含一个元素才满足该要求，不过先写 `..` 还是先写 `_` 都无所谓，因为编译器都能识别。

整体来说，看你个人喜好来书写代码。它们最终是一样的代码，都是序列不空且至少有一个元素。

### 2、三种括号一起用

假设我们有一个类型，它使用了这样的模式匹配：

```csharp
if (inst is () or [] or {})
    // ...
```

根据前面的知识，你可以猜测或者推断出，该类型的最小实现逻辑吗？换言之，你知道它允许这些模式匹配同时使用的时候，至少有多少个必需的成员存在呢？我们来想一想。

首先是 `()`。`()` 代表的是它是一个元组，但不包含任何数值。如果要找到“最优解”，只需要表示出 `inst` 变量是不是 `ITuple` 的实现类型就可以了。只要它实现自 `ITuple` 接口，那么对象就可以支持和兼容 `()` 模式，不需要定义任何新成员。哪怕它不走 `ITuple` 派生，只要 `inst` 是 `object` 类型，那么这种模式匹配就是成功兼容的，就不会出现语法错误。

其次是 `[]`。列表模式要求对象至少是集合类型，那么对象至少有一个带 `int` 单参数的索引器，以及一个 `Length` 或 `Count` 属性的其中一个即可。那么，这至少就需要对象有两个成员的实现。

最后是 `{}`。属性模式的唯一要求是，该类型不能是指针。因为指针类型永远都不包含任何判断属性。它只能取出其中的数值（`*p`）然后才可能有对应的属性。因此为了尽量包容和兼容前面的模式，那么我们假设 `inst` 此时是 `object` 类型。那么由于它不是指针，因此属性模式就可以使用（即使我们知道 `object` 里不包含任何可访问的属性信息）。

所以，要想满足三种括号一起使用的模式匹配的话，那么至少需要对象从语法上实现两个成员（`Length` 或 `Count` 其一，然后一个 `int` 类型的单参数的索引器），然后 `inst` 是 `ITuple` 的实现类型即可：

```csharp
class T : ITuple
{
    public int Length => throw new NotImplementedException();

    public int this[int index] => throw new NotImplementedException();
    object? ITuple.this[int index] => throw new NotImplementedException();
}
```

### 3、过于复杂的递归模式匹配

考虑一种极端情况：

```csharp
class S
{
    public void Deconstruct(out S s) => s = this;
}
```

这意味着什么？这意味着我在使用解构模式的时候会产生这样的代码：

```csharp
var s = new S();
if (s is (({})))
    // ...
```

这个 `(({}))` 是一个嵌套模式，不过没什么特殊意义。我们拆开看看就明白了。首先 `(({}))` 最外层是一个 `()` 模式，它表示对象可以解构就行，因此它等价于 `s is not null`；然后里面一层是 `({})` 的 `()`。它代表我在使用 `Deconstruct` 产生解构对象了之后又一次作判断。但 `Deconstruct` 是我写的一种极端代码：它解构了一个寂寞——返回了它自己。所以内层的 `({})` 的 `()` 还是跟原来判断信息完全一样。最后，最内层有一个空大括号，它表示空属性模式匹配，它依然和 `o is not null` 表达式等价，因此，完整的表达式和你写一个 `s is {}` 或 `s is not null` 没有区别。

你觉得好玩的话，我这还有一个例子。

```csharp
class S
{
    public int Length { get; }
    public S this[int index] => null;

    public void Deconstruct() { }
    public void Deconstruct(out S s) => s = this;
}
```

然后模式匹配：

```csharp
var s = new S();
if (s is ([{}]) or [[[[]]]])
    // ...
```

蛇皮怪。

我们强烈不建议你这么写代码，我之所以讲这个是为了告诉你有这么一种特殊的情况。而且，虽然没有这么多层级的嵌套，但经常会有括号嵌套括号的用法，两层还是蛮常见的：

* `((var a, var b), var c)`：将对象解构为两个值，用对位模式判断。其中第一个值可继续解构，并仍然使用对位模式继续对位判断；第二个值使用的是 `var` 模式；
* `([var a, var b], var c)`：将对象解构为两个值，用对位模式判断。其中第一个值使用列表模式判断；第二个值使用的是 `var` 模式；
* `({ Property: var a }, _)`：将对象解构为两个值，用对位模式判断。其中第一个值使用属性模式判断；第二个值使用的是弃元模式；
* `[(var a, var b), var c]`：使用列表模式判断对象是否只有两个值。其中列表模式里的第一个值可解构为两个值，并都使用 `var` 模式；第二个值使用的是 `var` 模式；
* `[[var a, ..], [.., var b]]`：使用列表模式判断对象是否只有两个值。其中第一个值可继续使用列表模式判断，并只判断该列表里的其中第一个值，使用 `var` 模式；第二个值也使用列表模式判断，且只判断该列表里的最后一个值，使用 `var` 模式；
* `[{ P1: 42 }, [var p2], (p3: 0)]`：使用列表模式判断对象是否只有三个值。其中第一个值使用属性模式判断 `P1` 属性；第二个值使用列表模式判断该列表是否只包含一个值，并使用 `var` 模式将该值取出；第三个值使用对位模式判断 `p3`；
* `{ Property: (var a, var b, _) }`：使用属性模式判断属性 `Property`。该属性的结果可继续使用对位模式判断三个值，前两个值都用 `var` 模式，最后一个是弃元模式；
* `{ Property: [var a, .., var b, _] }`：使用属性判断属性 `Property`。该属性的结果可继续使用列表模式，并判断第一个元素和倒数第二个元素，都用 `var` 模式；
* `{ Property: { Nested1: 42, Nested2: 0 } }`：使用属性模式判断属性 `Property`。该属性的返回值还可继续使用属性模式判断其中的 `Nested1` 和 `Nested2` 模式。

## 模式匹配的未来

C# 对模式匹配相当注重，因此所有添加进来的模式都是相当有趣且有意义的。在以后的 C# 版本里，C# 还会继续更进模式匹配语法，使得模式匹配更加好用。

有很多有关模式匹配语法优化的提案，下面列举一些：

* [`is` 运算符重载](https://github.com/dotnet/csharplang/issues/1047)（Overloadable operator `is`）：允许自定义 `operator is` 的语法来完成自定义 `is` 匹配规则；
* [自定义模式匹配](https://github.com/dotnet/csharplang/issues/4131)（User-defined Positional Pattern）：允许方法等成员放在 `is` 后进行匹配的规则；
* [`IEnumerable<T>` 列表模式](https://github.com/dotnet/csharplang/blob/main/proposals/list-patterns-enumerables.md)（`IEnumerable<T>` Pattern）：对于 `IEnumerable<T>` 类型由于目前没有索引器支持所以它不支持列表模式，该提案将它翻译成 .NET API 方法调用来支持列表模式匹配；
* [`or` 和 `not` 模式下的变量定义增强](https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md)（Variables under Disjunctive Pattern）：允许在包含 `or` 模式的两侧定义变量；
* [索引器模式](https://github.com/dotnet/csharplang/discussions/4889)（Indexer Pattern）：允许使用类似索引器的调用方式来判断属性规则的新匹配模式；
* [UTF-8 字符串字面量](https://github.com/dotnet/csharplang/blob/main/proposals/utf8-string-literals.md)（UTF-8 String Literal Pattern）：允许给字符串末尾加一个 `u8` 或 `U8` 后缀，使得它是 UTF-8 编码的字符串（例如 `"Hello"u8` 这样的语法）。虽说这个跟模式匹配没啥大关系，但是以后说不定会创建单独的数据类型，于是可能会有针对于这种类型的模式匹配语法；
* [`out` 赋值模式](https://github.com/dotnet/csharplang/discussions/6199)（`out` Pattern）：允许在已经定义好变量之后，使用 `is out 变量` 模式来判断类型并在类型匹配时将变量往外侧转换和赋值。

稍微提及一下这些特性吧。

### 1、`is` 运算符重载

允许用户自定义 `operator is` 的语法来完成自定义的模式匹配规则：

```csharp
public class T
{
    public static bool operator is(int flag)
    {
        return (this & flag) == flag;
    }
}
```

比如这样。然后你可以这么写代码：

```csharp
if (obj is T(10))
    // ...
```

嗯对，长得就跟对位模式匹配一样，不过这里可以传入一定的参数，使得对象可以进行自定义的判断。不过这个规则和现有的对位模式语法冲突了，因此可能不会采用这样的语法，不过这个功能说不定以后会出现，只不过可能会换别的语法来完成。

### 2、自定义模式匹配

允许用户定义一个方法，使得该方法满足一定的模式匹配要求，这样的方法就可以放在 `is` 之后了。假设我这样写代码：

```csharp
public bool Odd(this int i) => (i & 1) != 0;
```

比如我定义了一个 `int` 类型的扩展方法，于是你可以这样写代码：

```csharp
if (integer is Odd())
    // ...
```

是的，`Odd` 是方法名，然后参数表列已经被提前到 `integer` 这里了，因此不需写出参数；然后参数表列是空的，因此要有一对空括号。该提案也允许传参：

```csharp
public bool HasFlag(this int i, int flag) => (i & flag) == flag;
```

然后：

```csharp
if (integer is HasFlag(0x1000))
    // ...
```

这样的用法。

### 3、`IEnumerable<T>` 列表模式

现有的语法规则约定导致 `IEnumerable<T>` 虽然允许 `foreach` 但不能使用列表模式，因为它没有 `Count` 或 `Length` 属性，也没有索引器。

说不定以后会针对于它有特殊的语法处理规则呢？

### 4、非 `and` 模式的变量定义

现在的语法要求我们不能定义变量在 `or` 和 `not` 模式里，除了 `not` 模式是纯正的 `not`：

```csharp
if (obj is int a or double b)
    // ...
if (obj is not null or var a)
    // ...
if (obj is not null and not var a)
    // ...
```

这些都不行。因为目前的 C# 类型体系不支持我们使用类似 `int a or double b` 这样的“两者选择其一”的语法规则。该语法在 C# 里是有提案的，叫做**可区分联合**（Discriminated Union），在别的编程语言里有，比如 F#。但是，C# 并不支持该特性。

如果有了这个玩意儿的话，想必上面的这种定义模式说不定就有可能存在了。

### 5、索引器模式

索引器模式的用法其实可以不必多说，因为看名字估计就可以猜到了。它和 C# 11 的列表、分片模式不同，索引器模式是一种和属性模式语法类似的匹配模式，但它可以更为灵活地处理和判断指定索引上的数据的模式。

举个例子，我要判断第 12 个位置上的数据的话，如果按照列表模式的语法的话，就会非常不方便：我要定义一大堆的 `_` 弃元符号来占位；但是用索引器模式就可以很方便地描述出来：

```csharp
if (obj is { [12]: { } valueAtIndex12 })
    // ...
```

我们使用 `[12]` 来表示取 12 号索引器的规则。另外，这个提案包含了扩展属性模式的语法，因此索引器模式的提案自然包含所谓的“拓展索引器模式”或者是“索引器模式和属性模式的混用语法”。

```csharp
if (obj is { [12].NestedProp: not null })
    // ...
```

假设我有这样的语法，`[12].NestedProp` 是啥意思呢？就是 `[12]` 索引位置上的元素的 `NestedProp` 属性的数值是多少。所以，它的完整写法是：

```csharp
if (obj is { [12]: { NestedProp: not null } })
    // ...
```

当然，如果连续的索引器模式放在一起，提案没有规定语法，不过我猜测的语法是 使用小数点连接。

```csharp
if (obj is { [12].[3]: { } valueAtNestedArray })
    // ...
```

比如这样的语法，`[12].[3]` 模式表示的是原本对象的第 12 号索引上的对象。假设这个取出的对象还可以继续使用索引器的话，那么再次对其使用 `[3]` 模式可以得到对应的对象结果，进行模式匹配。所以这样的语法等价于：

```csharp
if (obj is { [12]: { [3]: { } valueAtNestedArray } })
    // ...
```

是这样的。当然，提案包含分片的模式规则，所以还可以这样：

```csharp
if (obj is { [3..^2]: { Count: >= 10 } slice })
    // ...
```

类似这样的逻辑。

### 6、UTF-8 字符串字面量的模式匹配

C# 11 开始支持 UTF-8 字面量。所谓的 UTF-8 字面量，指的是一个字符串，里面只能包含 UTF-8 格式的字符，构成的字面量形式。它们每一个字符只占据一个字节的内存空间大小，和目前的 `char` 类型占据两个字节形成对比。

C# 11 开始允许使用 `u8` 或 `U8` 后缀，对字符串的字面量进行修饰。现在 C# 11 支持如下这些字符串的 UTF-8 字符串字面量形式：

* 普通字符串字面量：`"hello"u8`；
* 原义字符串字面量：`@"hello"u8`；
* 原生字符串字面量（C# 11 起可用）：`"""hello, world!"""u8`。

这些字面量形式均可使用 `u8` 或 `U8` 后缀。将其改造为只占据单字节的字符的字符串信息序列。

现已知的是，C# 正在考虑这个特性，但是目前因为没有此类型可以对应和兼容该字符串，所以目前这种字面量是直接赋值给 `ReadOnlySpan<byte>` 或 `byte[]?` 类型的。毕竟，UTF-8 格式的话，只有 256 种情况，这刚好兼容的是 `byte` 类型的范围。你想想，C 语言里 `byte` 没有这种类型，不也用的是 `unsigned char` 来代替的吗？它们是可转换的。

和前文介绍的 `ReadOnlySpan<char>` 模式匹配语法类似，C# 有望支持对这种字符串的模式匹配规则。不过目前来说，由于特性还在考虑之中，因此还需要进一步的研究和提案，因此暂时并不支持对此类型的字符串支持模式匹配的规则。

对于以后，模式匹配可能会有令人惊艳的用法和规则，让我们一起期待这一天的到来。

### 7、`out` 变量赋值模式

这个提案的赋值模式特别有意思。考虑如下的代码：

```csharp
object obj = 123;
string name;

// Does not match as the value is not compatible with string.
if (obj is out name)
    // ...
```

这种模式约束和规定，在判断 `obj` 的具体类型，必须和 `out` 后跟的变量的类型一致。如果一致的时候，才会往里面赋值。它等于这样的语句：

```csharp
if (obj is string tempName)
    name = tempName;
```

这样的定义有一个弊端是，它会多出来一个变量的定义，而该变量是没有意义的：它不必定义出来。但是，如果你去掉的话，你又必须使用强制转换：

```csharp
if (obj is string)
    name = (string)obj;
```

两种用法都是复杂的。所以，该提案制定了一种新的规则：`is out` 模式，在 `out` 后跟一个变量，而该变量的类型就决定了 `is` 左侧的判断表达式的匹配类型。如果类型是一致或兼容的的话，那么赋值过程就是成功的。

该提案有一个问题在于，`name` 在如果没有初始化的状态下，进行 `is out` 匹配，那么成功或失败就会导致 `name` 是否被初始化会更加难以预测。编译器对于这样的分析是痛苦的，这是需要克服的问题。可能该提案尚未完善，对于这样的规则可能使用一些其它的规则去补充漏洞，例如匹配失败时会自动往该变量赋值 `default(T)`，其中的 `T` 是这个变量的类型。那么这样的话：

```csharp
var temp = obj is T variable ? variable : default;
```

类似这样的语句，就可以简化一下了：

```csharp
T temp;
_ = obj is out temp;
```

通过弃元来放弃对 `is out` 模式匹配成功和失败的最终布尔数值结果，然后对 `is out temp` 的方式来进行 `obj` 的转型和赋值。

## 总结

下面列举前文所有模式匹配，每一种模式在 C# 里出现和允许使用的版本号。

| 模式类型名称              | 什么版本起可用 | 语法举例                          | 备注                         |
| ------------------------- | -------------- | --------------------------------- | ---------------------------- |
| 声明模式                  | C# 7           | `expr is T v`                     |                              |
| `var` 模式                | C# 7           | `expr is var v`                   |                              |
| 常量模式                  | C# 7           | `expr is 0`                       |                              |
| 对位模式                  | C# 7           | `expr is (A: _, B: 1, C: "")`     |                              |
| 解构模式                  | C# 7           | `expr is var (_, second, last)`   |                              |
| 弃元模式                  | C# 7           | `expr is (_, _, _)`               |                              |
| 类型模式                  | C# 7           | `expr is T`                       |                              |
| 属性模式                  | C# 8           | `expr is { Prop: _ }`             |                              |
| 关系模式                  | C# 9           | `expr is < 100`                   |                              |
| 逻辑模式                  | C# 9           | `expr is > 0 and < 100`           |                              |
| 扩展属性模式              | C# 10          | `expr is { Parent.Nested: _ }`    |                              |
| 列表模式                  | C# 11          | `expr is [1, _, .., _, 3]`        |                              |
| 分片模式                  | C# 11          | `expr is [1, _, .. var slice, _]` |                              |
| 模模式                    | C# 11          | `expr is { Length: not 0 }`       | 仅为编译器分析，不是新语法。 |
| `ReadOnlySpan<char>` 模式 | C# 11          | `readOnlySpanExpr is "Hello"`     |                              |

