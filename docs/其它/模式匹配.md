# 模式匹配详解（第六修订版）

## 模式匹配是啥？

**模式匹配**（Pattern Matching），在编程里指的是，把一个不知道具体数据信息的玩意儿，通过一些固定的语法格式来确定模式数据的具体内容的过程。

C# 的模式匹配非常美丽，因为语法格式非常有趣、简单、且更具有可读性。下面我们来看看 C# 的模式匹配。

## C# 各种各样的模式

C# 里有很多种类的、用来控制和判断数据的**模式**（Pattern），它们语法不同，判断的东西、语义也不一样。下面我们列举它们。

### 声明模式（Declaration Pattern）

#### 语法

声明模式用于简单判断一个模糊的数据类型是否是某个具体的数据类型，并尝试将其转换过去。

```csharp
object greeting = "Hello, World!";
if (greeting is string message)
{
    Console.WriteLine(message.ToLower());
}
```

注意语法 `greeting is string message` 的写法。C# 最开始允许 `is` 的写法是 `obj is T`，而 `T` 之后写的变量指的是“如果 `obj` 确实是 `T` 类型的实例的话，那么 `message` 就可以使用了”。换句话说，这段代码等价于下面这样的代码：

```csharp
object greeting = "Hello, World!";
if (greeting is string)
{
    string message = (string)greeting;
    Console.WriteLine(message.ToLower());
}
```

即在大括号里等效进行类型转换。

#### 声明模式仍可能会进行拆箱

假设我们原始的对象是装箱的操作：

```csharp
object o = 3;
```

那么，即使你使用这个语法来获取结果：

```csharp
if (o is int v)
    Console.WriteLine(v);
```

它也避免不了拆箱行为：因为它等于 `o is int` 后直接进行 `int v = (int)o` 的拆箱赋值操作，所以它会隐式地进行拆箱，它是避免不了的。

### `var` 模式（`var` Pattern）

#### 语法

有一些时候，我们可以内联模式匹配和变量声明。

```csharp
static bool IsAcceptable(int length, int absLimit)
{
    return SimulateDataFetch(length) is var results
        && results.Min() >= -absLimit
        && results.Max() <= absLimit;
}

static int[] SimulateDataFetch(int length)
{
    var rand = new Random();
    int[] result = new int[length];
    for (int i = 0; i < length; i++)
    {
        result[i] = rand.Next(-100, 100);
    }

    return result;
}
```

我们来看下这个例子。`SimulateDataFetch` 方法获取指定长度的数组，数组的每个元素都是 -100 到 100 之间的随机数。`IsAcceptable` 方法则是验证序列是不是在某个数字的范围内。可以从例子里看出，我们直接将方法调用的结果直接内联到 `return` 语句里，我们写的是 `is var results`。这个语句和下面这段代码相当：

```csharp
int[] results = SimulateDataFetch(length);
return results.Min() >= -absLimit && results.Max() <= absLimit;
```

#### 声明模式和 `var` 模式的区别

请稍微注意一下。`var` 模式和声明模式的书写格式完全一样，唯一的区别是，一个写的是类型的具体名称，一个则是写的固定的关键字 `var`。声明模式下，写的数据具体类型会作为数据的判断类型进行判断；而 `var` 仅等价于变量声明，它并不具有任何的数据类型的判断。

虽然我们可以看到，`var` 模式的例子里，由于 `SimulateDataFetch` 方法返回的 `int[]` 类型是固定的，因此我们完全可以写成 `SimulateDataFetch(length) is int[] results`。但是，由于这个写法写的是具体类型，因此 C# 会做一次没有意义的数据判断：判断结果是不是 `int[]` 类型的。但显然这个判断是没有意义的，因此我们建议在这种“变量内联到条件里”的情况，使用 `var` 模式而不是声明模式。

### 常量模式（Constant Pattern）

#### 语法

常量模式针对于一个可能为 `null` 的数据类型的实例，判断是否等于某个具体的常量。

```csharp
object o = 3;
if (o is 30)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

在这段代码下，我们直接在 `is` 后紧跟一个数值，这表示将 `object` 进行类型和数值的双重判断。等价的代码是这样的：

```csharp
object o = 3;
if (o is int i && i == 30)
    Console.WriteLine("The condition is true.");
```

那么，为什么非得是 `int` 呢？因为这里的 3 这个字面量，默认是 `int` 类型的，因此这里在等价代码里用的是 `int` 作为类型的判断。

#### 可空值类型的常量模式匹配是不必要的

另外，我们也可以对一个可空值类型使用这样的常量模式判断。

```csharp
int? i = null, j = 30;
if (i is 3 && j is 3)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

比如这个格式。这个格式很明显等价于 `i is int p && p == 3 && j is int q && q == 3`。正是因为写起来很长，所以我们才会使用这样的模式匹配来简化代码。不过，这个模式匹配是不必要的。早在可空值类型出现的时候，它们自身的等号和不等号的逻辑就已经可具有这样的判断了。换句话说，你写成这样，和模式匹配的格式将是一样的等价代码。

```csharp
int? i = null, j = 30;
if (i == 3 && j == 3)
    Console.WriteLine("The condition is true.");
else
    Console.WriteLine("The condition is false.");
```

这里，`i` 就算是 `null`，也不会影响判断 `i == 3` 的结果。大不了结果为 `false` 就是了。

### 对位模式（Positional Pattern）

#### 语法

对位模式是将一个数据成员通过解构方法来产生解构，来判断属性数据的过程。假设我们拥有这样一个数据类型：

```csharp
public readonly struct Point
{
    public int X;
    public int Y;
}
```

显然这里的 `X` 和 `Y` 是 `Point` 里仅存的两个数据成员。如果我们在某个时刻判断数据信息的具体数值的时候，我们可能会使用如下的写法：

```csharp
if (point.X == 30 && point.Y == 30)
    // ...
```

在 C# 里，我们只要写上一个自定义的解构函数，就可以对对象进行解构操作。我们写一个 `Deconstruct` 方法，然后带有两个参数：`x` 和 `y`，它们都是 `out int` 类型的。

```csharp
public void Deconstruct(out int x, out int y)
{
    x = X;
    y = Y;
}
```

通过这样的赋值后，我们就可以通过这个解构来完成数据的解构了：

```csharp
var point = new Point { X = 10, Y = 60 };

// Deconstruct.
var (x, y) = point;
```

当然，在模式匹配的时候，我们可以使用这样的代码对上面的写法进行简化：

```csharp
if (x == 30 && y == 30)
    // ...
```

不过，这样还不是很好看。因此 C# 还有这样的对位模式匹配：

```csharp
if (point is (x: 30, y: 30))
    // ...
```

通过一对小括号，我们可以实现对这个数据成员具体数值的检测。至于这里为什么是小写字母 `x` 和 `y`，是因为解构函数的参数分别是 `x` 和 `y`，这是一一对应的。正是因为如此，这个模式才叫做对位模式。其中，因为它借助了解构函数，而解构后的对象分配使用的是一对小括号（`var (x, y) = point;` 这个语句），因此为了配合这个写法，也用的是小括号。只是这里需要写出解构参数的名字。

稍微注意一点的是，C# 允许在同一个数据类型下定义多个解构函数，所以这正是为什么必须给出解构参数名称的原因。除非这个类型就这一个解构函数，那么我们都必须写出解构参数名。

#### 主构造器的对位模式

C# 9 和 C# 10 分别诞生了记录类型和记录结构类型，它们必须绑定一个主构造器位于声明的头部：

```csharp
record Person(string Name, int Age, bool IsBoy);
```

在使用模式匹配的时候，由于编译器会自动生成对应的解构函数，因此我们可以直接对主构造器使用对位模式匹配。

```csharp
if (person is Person (Name: "Sunnie", Age: 25, _)) ;
```

其中，小括号 `(Name: "Sunnie", Age: 25, _)` 左侧的数据类型类似于 `obj is T t` 的 `T`，而小括号书写出来的对位模式，则是 C# 允许的语法。它们甚至可以写在一起。当然，如果类型一样就不必判断类型了。

#### 调用扩展方法的对位模式

同时，编译器也能够嗅探扩展方法。换句话说，对位模式也允许扩展方法的解构函数。因此，C# 也允许调用扩展方法的解构函数来对位判断元素信息。

```csharp
static class Extensions
{
    public static void Deconstruct<T>(this T[] array, out T firstElement, out T secondElement)
    {
        firstElement = array[0];
        secondElement = array[1];
    }
}
```

于是我们可以使用这个方法对一个 `T[]` 进行解构：

```csharp
int[] arr = { 1, 3, 10 };
if (arr is (firstElement: 1, secondElement: var secondElement))
{
    Console.WriteLine(secondElement);
}
```

### 解构模式（Deconstruct Pattern）

#### 语法

因为前文我们拥有了解构函数，也拥有了 `var` 模式，因此 C# 灵活的语法提供了 `var` 模式的解构版本：

```csharp
if (point is var (x, y) && x == 30 && y == 30)
    // ...
```

稍微注意一下这里的语法是写成 `var (x, y)`。当然，你也可以内联 `var` 关键字。和值元组的语法一致，你依然可以用 `(var x, var y)` 的语法。

```csharp
if (point is (var x, var y) && x == 30 && y == 30)
    // ...
```

这样是可以的。

> 不过严谨一点的话，`var (x, y)` 是解构模式，而 `(var x, var y)` 是对位模式。因为前者使用 `var (x, y)` 语法，小括号里直接定义了变量名，小括号的外侧则是 `var` 关键字；但 `(var x, var y)` 在小括号里定义了两个变量，都使用了 `var` 关键字，这意味着是对应位置上的数据分别定义变量，类似 `point.X is var x && point.Y is var y` 的效果，因此只能说是对位模式。

#### 可空值类型解构模式的别样意义

在 C# 里，可空值类型一直是一种方便也不方便的数据类型。它的声明和使用都比较方便，但问题就出在它可能是 `null` 数值。假设前文的 `Point` 我们用的是可空类型的话：

```csharp
Point? nullable = new Point { X = 30, Y = 30 };
```

此时，我们在后续的代码里，无从根据代码直接确定 `nullable` 是否为 `null`（除非看取了 `nullable` 的值才行）。因此，一旦我们对这个类型进行解构：

```csharp
if (nullable is var (x, y))
    // ...
```

这就不单纯和 `var` 模式一样。它牵扯到数据是不是 `null` 才可解构的问题。如果数据都是 `null` 了，我们就无法解构。因此，可空值类型的解构模式会先判断对象是不是不为 `null`，然后才是解构。

```csharp
if (nullable != null && nullable.Value is (x: var x, y: var y))
    // ...
```

> `nullable != null` 和 `nullable.HasValue` 是等效的，所以写 `nullable.HasValue` 也没问题。

#### 主构造器的解构模式

是的，主构造器会自动生成对应的解构函数，因此完全可以直接使用解构模式。还是使用之前的 `Person` 类型：

```csharp
record Person(string Name, int Age, bool IsBoy);
```

那么，有这样的语法：

```csharp
if (person is var (name, _, isBoy)) ;
```

这样是允许的。但你不能写 `is Person (name, _, isBoy)`，因为前面的 `var` 关键字是这个模式匹配的固定格式，改成了 `Person` 的话，后面就只能看成对位模式了。

#### 调用扩展方法的解构模式

解构模式和对位模式类似，编译器也支持嗅探解构模式对应的扩展方法。一般正常的实现我们可能对一些数据类型无法实现解构操作，因此我们需要扩展方法来达到一些行为。比如假设我要去获取数组的前两个元素，我们经常会使用 `[0]` 和 `[1]` 来获取，不过现在我们可以使用解构模式来完成：

```csharp
static class Extensions
{
    public static void Deconstruct<T>(this T[] array, out T firstElement)
    {
        firstElement = array[0];
    }
}
```

假设我随便这么写了这个扩展方法，它们用于解构 `T[]` 数组。于是我们可以对一个一维数组进行解构操作：

```csharp
int[] arr = { 1, 3, 10 };
if (arr is var (firstElement))
{
    Console.WriteLine(firstElement);
}
```

请注意解构函数正常使用的时候是尽量不出现 0 或 1 个元素的解构模式，不过在这个时候也可能会遇到，因此语法没有对此进行限制。

#### 解构和对位模式不要求判断元素数量至少两个

这里稍微说一个比较不容易了解到的知识点。编译器限制我们定义一个至少两个元素的值元组 `ValueTuple` 类型，也就是说，一个或零个的值元组类型是不被允许的：

```csharp
var emptyTuple = (); // Wrong.
ValueTuple<int> singleElementTuple = (1); // Also wrong.
```

注意，第 2 行的代码我们假设写的 `var` 而不是 `ValueTuple<int>` 的话，编译器会自动消去 `(1)` 两侧的小括号，然后直接认为它是 1；故意显式给出类型名是为了告诉你，这两个情况都是值元组不被允许的。

不过，虽然解构模式和对位模式长得都跟值元组的类型声明模式很像，但对位模式和解构模式允许和支持解构函数可以包含任意多的 `out` 参数用于解构，这也意味着在解构模式和对位模式里，`is ()` 或 `is (1)` 是存在的语法。而且，`(1)` 和 `1` 语法在模式匹配里不一致——`(1)` 是对位模式，且只判断其中解构出来的唯一一个数值是不是 1；而 `1` 是常量模式：这个模式直接看对象的数值是不是 1。

### 弃元模式（Discard Pattern）

#### 语法

一旦解构后，我们就有办法只判断其中的一个数据。假设前文的解构函数存在的话，那么我们必然会解构成两个数据（`x` 和 `y`）。但是，如果我们仅判断 `x` 的数据，而不关心 `y` 是多少的话，我们可以使用一个下划线 `_` 来表示“`y` 我们不用判断”，或者说“`y` 的模式匹配总是成立的”。

```csharp
if (nullable is (x: 30, y: _))
    // ...
```

或者

```csharp
if (nullable is var (x, _) && x == 30)
    // ...
```

这么写都是可以的。

#### 弃元模式的叫法和定义范畴

呃，前面只要带有 `_` 记号（弃元符号）的地方，这些模式就都可以叫弃元模式。不论你这个 `var (_, _)` 也好，还是 `{ Length: _ }` 也好，还是 `T _` 也好，甚至包括稍后介绍的一些新语法也好，它们都是在一个大的模式匹配表达式里的其中一个模式匹配单元，它们都称为弃元模式，只要是用到了弃元符号 `_` 的地方。

### 类型模式（Type Pattern）

#### 语法

与其单独讲类型模式，还不如让你先明白，声明模式的那个类型，就是类型模式。

```csharp
if (list is int[] arr)
    // ...
```

所以，你干脆理解成这样：“声明模式 = 类型模式（就是这个类型）+ 变量定义”。但是，单独提出来说，是有原因的。

#### 声明模式弃元

在 C# 里，`switch` 语句可以专门对一个不知道是什么类型的东西作模式匹配：

```csharp
switch (obj)
{
    case int[] arr: // ...
    case IEnumerable<int> enumerable: // ...
    case List<int> list: // ...
    default: // ...
}
```

这里，C# 也是允许的。可问题在于，`arr`、`enumerable` 等变量如果不用，我们无法去掉：C# 9 之前，这个变量是不可省去的：即使不用，你也得写弃元符号：`_`。

```csharp
switch (obj)
{
    case int[] _: // ...
    case IEnumerable<int> _: // ...
    case List<int> _: // ...
    default: // ...
}
```

不过，从 C# 9 开始，弃元符号就可以不写了。于是乎，模式匹配就可以简写成真正的类型模式了：

```csharp
switch (obj)
{
    case int[]: // ...
    case IEnumerable<int>: // ...
    case List<int>: // ...
    default: // ...
}
```

### 属性模式（Property Pattern）

#### 语法

属性模式是用于专门体现对象的属性信息的匹配模式。我们使用一对大括号来表达参数是否必须满足这个数值信息。

假如，我们现在的 `Point` 类型的 `X` 和 `Y` 不再使用字段表达，而是用属性来表达：

```csharp
public readonly struct Point
{
    public int X { get; }
    public int Y { get; }
}
```

那么，我们即使不给出解构函数，也可以使用属性的方式来对每一个成员信息进行判断：

```csharp
if (point is { X: 30, Y: 30 })
    // ...
```

属性模式专门给属性提供数据判断的服务，因此这种模式叫属性模式。

#### 属性模式的弃元

一般来说，属性模式下，由于不需要依赖于解构函数，因此属性是可以写出来判断的；反过来说，如果属性不判断的话，那么写出来就没意义了。不过 C# 的语法允许我们使用弃元来默认通过某个属性的判定：

```csharp
if (point is { X: 30, Y: _ })
    // ...
```

这样的话，`Y` 属性是永真式，即不用判断了。说白了，这里的 `Y: _` 是可以不写的。只是 C# 允许这种语法存在，体现出了语法的灵活性。

#### 空属性模式及变量声明内联

如果属性模式里的成员为空，那么它表示什么呢？

```csharp
if (nullable is { } point)
    // ...
```

是的，对于可空类型（不管是值类型也好，还是引用类型也好），都表示“不为 `null`”。比如 `nullable` 是一个可空的 `Point` 类型，那么 `is { }` 就表示 `nullable.HasValue`。当满足条件后，我们用 `point` 表示这个 `Point` 类型的数据。

从这个例子里，我们可以得到的若干信息是这些：

1. `is { }` 表示“不为 `null`”，适用于任何可为空的类型；
2. 大括号后可继续内联一个变量，和 `is T variable` 写法格式（声明模式）一致，但是，注意内联的这个变了和原始变量的类型和可空语义的不同：被匹配的变量（原始变量）是可空的，但是内联的后者这个变量是一定不空的。

> C# 是允许变量声明的内联作为模式匹配的一部分的。这里仅用空属性模式介绍了内联变量的写法，但你要知道的是，内联变量可用在任何情况下的属性模式。

#### 尽量不要让本来就不为 `null` 的表达式使用属性模式

可以发现，`is` 的左边其实可以为一个表达式。因此下面的代码是合法的：

```csharp
if (new Student("Sunnie", 25) is { } student)
    // ...
```

不过，这种写法具有副作用。`is` 的左边一定是一个不为 `null` 的表达式，那么我们就没有理由使用 `is { }` 来进行模式匹配。因为这样会导致编译器生成不必要的判空代码。

因此，为了避免这样的写法出现，我们可以改成 `var` 模式，或者是直接定义一个新的变量来进行赋值。

```csharp
// Way 1.
var student = new Student("Sunnie", 25);
// ...

// Way 2.
if (new Student("Sunnie", 25) is var student)
    // ...
```

请注意。这里所说的属性模式不单单只是空属性模式。在里面带别的属性使用 `var` 模式的话，也是不必要的写法。

```csharp
var student = new Student("Sunnie", 25);
if (student is { Name: var name, Age: var age })
    // ...
```

这种写法看似是在直接使用大括号语法来同时获取两个属性的数值，但是如果 `Student` 是引用类型的话，属性模式的大括号本身会让编译器自动生成判空代码，于是这样的代码等价于 `!ReferenceEquals(student, null) && student.Name is var name && student.Age is var age`。是的，它会做一次判断 `null` 的冗余操作。

如果你需要对多个这样的属性一齐取值的话，我建议你使用值元组来进行赋值：

```csharp
var (name, age) = (student.Name, student.Age);
```

用这样的语法来代替原来的写法。这样的赋值和原始的赋值的期望结果是一致的，但代码里也不会多出冗余的判空。

#### 可空值类型模式匹配是匹配的内部数值

判别对象是否为空，我们可以使用 `is null` 来完成，因此不空就使用 `!(obj is null)` 就可以了；与此同时，由于空属性模式也可以完成相同的行为，因此这样的代码也可以写成 `obj is { }`；对于可空值类型来说，我们还可以使用 `HasValue` 属性来完成：`obj.HasValue`。

但是，可空值类型在模式匹配里是当成值类型来假设的——它可能含有数值，那么数值直接拿出来即可；如果不含有数值，返回 `null` 就是判断模式的结果。而这里的 `HasValue` 是对所有可空值类型都具备的一个独特特性。但是在模式匹配里，你无法这么写代码：

```csharp
if (nullableValueObject is { HasValue: _ }) ;
```

比如属性模式，我们想要直接使用 `HasValue` 属性来完成属性模式匹配，这样的语法是错误的。因为编译器会假设 `nullableValueObject` 在模式匹配里是按数值进行判断的，即使它本身是可空值类型，但在模式匹配里它是被视为一个包含 `null` 的普通数值类型。比如说 `a` 是 `int?` 类型，那么 `a is { HasValue: _ }` 就是错误写法：因为 `a` 会被视为包含 `null` 的普通 `int` 类型，而不会被当成 `int?` 类型（即 `Nullable<int>` 类型）。这个意义在于，由于它进行模式匹配并不会被视为可空值类型，因此你无法使用 `{ HasValue: _ }` 类似的模式来获取其结果。

如果确实要获取可空值类型的内部数据，你应该写 `a is { } v` 或 `a.HasValue && a.Value is var v`，而不是 `a is { HasValue: _, Value: var v }`。

#### 用属性模式解构值类型对象

是的，C# 编译器确保了我们的操作完全只包含解构行为的时候，是可以不做判断即可使用这些变量的。举个例子。

```csharp
_ = stu is { Name: var name, Age: var age };
```

它不依赖于你的解构函数：只要对象具有该属性数值且包含 `get` 访问器可以用于取值操作，这个属性就可以用来作为属性模式解构操作的一部分。这种解构形式和之前学到的解构函数的解构模式不同，这里用的是属性模式的方式获取，因此称为**属性模式解构**（Property-pattern-styled Deconstruction）。

另外，上面用到了弃元符号。因为 `is` 表达式不可单独使用，它必须返回数值给变量调用。如果你确实不使用结果变量（实际上这个解构行为根本就不可能失败，所以上面这样的 `is` 表达式永远返回 `true`）赋值给等号左侧的话，只需要写弃元符号即可，它等价于这样：

```csharp
var name = stu.Name;
var age = stu.Age;
```

又或者是

```csharp
var (name, age) = (stu.Name, stu.Age);
```

等等写法。

另外，这样的解构风格允许你包含弃元模式嵌套在属性模式之中。但凡右侧 100% 是成功的解构操作的话，你怎么写模式匹配都可以：

```csharp
_ = obj is { A: _, B: { Nested: var nested, SecondNested: _ } _, C: var propCValue };
```

这些都是编译器允许的写法。这种就是带有递归使用的解构，它也是编译器允许的，因为这样的解构操作肯定是成功的。否则，由于可能失败，所以带有别的模式匹配的话，你可能就得用 `if` 来判断一下才知道是否模式匹配成功了。

```csharp
if (obj is { A: 10, B: { Nested: var nested, SecondNested: _ } _, C: var propCValue })
{
    // ...
}
```

这样的话，由于 `A` 属性判断了数值，所以可能解构操作不成功，这种场合你只能使用 `if`，而且不能简化成上面属性模式风格的解构的样式。顺带一说，`_ = a is pattern` 表达式的 `_` 不是模式匹配，它只是表示变量我们不使用了。

#### 递归模式Ⅰ：属性模式递归

C# 强大的地方在于，语法很灵活，这样我们写代码可以不用唯一的一条道路去实现。比如前面的解构模式。`(x: var x, y: var y)` 里又是一个 `var` 模式的变量声明。所以，正是因为这样，我们学 C# 就不必学得那么痛苦。

C# 的属性模式是 C# 一大秀儿语法。它允许递归使用属性模式进行判断。假设我有这么一个对象：

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Gender Gender { get; set; }
    public Person? Father { get; set; }
    public Person? Mother { get; set; }
}
```

这个对象是表示一个人的基本数据信息，比如名字啊、年龄啥的，当然也存储了 ta 的父母的实例的引用。

> 其中，我们假设 `Gender` 类型是个暂时只包含 `Male` 和 `Female` 俩字段的枚举类型。
>
> `Person?` 语法表示 `Person` 这个引用类型具有和值类型类似的语法：这个属性信息可为 `null`。反之，如果没有 `?` 标记的类型，这个成员的数值就不能为 `null`。这个语法是 C# 8 里的，这里为了体现出判断用法，故意写上了 `?` 来表达为 `null`、更显眼一点；另外，这里故意取可为 `null` 的写法，还有一个目的，是为了体现一会儿模式匹配的语义，所以请不要和现实世界进行对比或者对号入座。

假如，我们要判断是否某个人的姓名是“张三”、年龄 24，他爸叫“张二”、而他的妈妈则叫“李四”。如果要判断这个对象的具体信息，我们可以这么写代码：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father: { Name: "Zhang 'er" },
        Mother: { Name: "Li si" }
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

注意这里的模式匹配写法。前面模式匹配就用的是大括号，因此我们可以对对象的内部信息继续作判断。比如 `Father` 和 `Mother` 属性又是一个 `Person` 类型的对象，因此我们还可以接续一个大括号对 `Father` 和 `Mother` 的值的具体内容继续进行判断。

一定要注意。`Father` 和 `Mother` 属性是可能为 `null` 的。当 `Father` 属性的数值本身就是 `null` 的时候，那么显然就不存在 `Name: "Zhang 'er"` 的判断行为了：因为 `null` 值本身就无法继续判断内部数据了。因此，在 `Father` 为 `null` 的时候，模式匹配结果一定是 `false`。当且仅当整个判断的逻辑全都匹配，`if` 条件才成立。

顺带给大家看下，C# 的模式匹配到底多有魅力：给大家展示一个我之前写过的一段代码，用到了这里的模式匹配。

```csharp
if (
    node is
    {
        Expression: MemberAccessExpressionSyntax
        {
            RawKind: (int)SyntaxKind.SimpleMemberAccessExpression,
            Expression: MemberAccessExpressionSyntax
            {
                RawKind: (int)SyntaxKind.SimpleMemberAccessExpression,
                Expression: IdentifierNameSyntax
                {
                    Identifier: { ValueText: "TextResources" }
                },
                Name: IdentifierNameSyntax
                {
                    Identifier: { ValueText: "Current" }
                }
            },
            Name: IdentifierNameSyntax
            {
                Identifier: { ValueText: var methodName }
            } nameNode
        },
        ArgumentList: var argList
    }
)
{
    // ...
}
```

这里，这么一大坨都是递归的模式匹配。正好这体现出了模式匹配的魅力。

#### 递归模式Ⅱ：对位模式和属性模式是可以放在一起的

C# 的属性模式具有和对位模式完全一致的判断行为，因此 C# 就把对位模式和属性模式在语义分析上放在了一起。假设我有一个 `Point` 类型，包含 `X` 和 `Y` 属性（它们通过解构函数解构为 `x` 和 `y` 两个参数），并且包含 `Area` 属性表示当前点到坐标原点构成的矩形的面积。

这里不是讲数学，我只是告诉你如何并用两个模式。

```csharp
if (point is (x: 10, y: 30) { Area: _ }) ;
```

可以看到，我们直接在 `(x: 10, y: 30)` 这个对位模式后加上了 `{ Area: _ }` 属性模式。在 C# 里，对位模式和属性模式均可以用于递归使用（比如假设一个对位模式的成员是可以继续通过别的模式进行匹配的，那么这个成员就可以继续递归地进行模式的判断），同时属性模式也是如此，前文已经说过了。因此，C# 把对位模式和属性模式统称**递归模式**（Recursive Pattern）。换句话说，在概念上来讲，你可以同时使用对位模式和属性模式的两种不同模式的判别，并放在一起，这个整体叫做递归模式。

但请注意，必须是先对位模式，后属性模式的顺序。写反了是不行的。

### 关系模式（Relational Pattern）

#### 语法

前面的模式可以解决一大部分的问题了，但是有些时候，数据判断和取值无法对一个范围来判断，因此还不够灵活。C# 里还有关系模式，来对数据的范围来判断。

```csharp
if (obj is > 30)
    // ...
```

即使 `obj` 不是 `int` 类型，我们依旧可以这么写。这个代码等价于 `obj is int i && i > 30`。

C# 允许 `>`、`>=`、`<` 和 `<=` 四个运算符，写在 `is` 后，来表达范围判断。稍微注意一下的地方是，`is > 30` 的 30 必须是常量才行。

给大家看一个例子：

```csharp
Console.WriteLine(Classify(13)); // output: Too high
Console.WriteLine(Classify(double.NaN)); // output: Unknown
Console.WriteLine(Classify(2.4)); // output: Acceptable

static string Classify(double measurement) => measurement switch
{
    < -4.0 => "Too low",
    > 10.0 => "Too high",
    double.NaN => "Unknown",
    _ => "Acceptable",
};
```

不过怎么理解，就靠你自己了。

#### 不推断类型的时候，不要用模式匹配

正是因为出了这个模式，下面两句话就变成等价的了：

```csharp
int v = 30;

bool condition1 = v > 30;
bool condition2 = v is > 30;
```

显然，要不要 `is`，语句都可以理解。但是，有 `is` 需要模式匹配，因此显然复杂一点。因此，我们建议在数据类型不用判断的时候，不要使用 `is`。当然，这里说的结论指的是这里这种情况。

### 逻辑模式（Logical Pattern）

因为模式匹配里的每个模式并不是一个“数据信息”，因此我们无法直接对模式用 `&&`、`||` 等符号来进行拼接组合。C# 为了解决这个问题，多了三个关键字：`and`、`or` 和 `not` 来拼接模式。

#### 合取模式

合取模式用 `and` 拼接模式，来表达这些模式都必须成立。

```csharp
static bool IsLowerLetter(char c) => c is >= 'a' and <= 'z';
```

比如这里，`>= 'a' and <= 'z'` 整个表达式用来表达，`>= 'a'` 和 `<= 'z'` 两个条件必须都满足。如果要写分开，就必须写成 `c is >= 'a' && c is <= 'z'`。

#### 析取模式

析取模式用 `or` 拼接。

```csharp
static bool IsLetter(char c) => c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z');
```

注意，`or` 拼接了前面 `>= 'a' and <= 'z'` 和后面 `>= 'A' and <= 'Z'` 两个模式。`or` 表示两个模式有一个模式能够匹配成功就可以。

#### 取反模式

取反模式用 `not`。

```csharp
if (input is not null)
    // ...
```

最常见的就是这里。我们如果判断对象是不是不为 `null`，那么我们最常用的就是写成 `is not null`。`is null` 属于前面的常量模式，判断对象是不是 `null`。它和 `==` 运算符的区别是，`==` 运算符可重载，重载会影响 `==` 的判断和使用逻辑；而 `is` 是永远不变的判断模式。

#### 混用析取、合取和取反

当然，你也可以混用到 `and` 和 `or` 关键字拼接起来的模式里。

```csharp
if (ch is >= '0' and <= '9' or '.')
    // ...
```

这表示 `ch` 是不是字符 0 到 9，或者是小数点。将其取反：

```csharp
if (ch is not (>= '0' and <= '9' or '.'))
    // ...
```

这就表示取反。当然了，你可以使用类似数学知识，将 `not` 套到小括号里：

```csharp
if (ch is not (>= '0' and <= '9' or '.')) ;
if (ch is not ((>= '0' and <= '9') or '.')) ;
if (ch is not (>= '0' and <= '9') and not '.') ;
if (ch is (not >= '0' or not <= '9') and not '.') ;
```

这 4 行内容可以帮助你理解和拼接模式的具体内容。

#### 合取式、析取式和取反式的优先级

稍微注意一下。合取式 `and` 和数学上是一样的，比 `or` 更优先推理，因此无需对 `and` 和 `or` 模式一起的复杂模式匹配添加括号：

```csharp
static bool IsLetter(char c) => c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z');
```

比如这样，`(>= 'a' and <= 'z')` 和 `(>= 'A' and <= 'Z')` 的小括号可以不要。

取反式的话，因为它只和一个模式结合使用，不像是 `and` 和 `or` 需要两个模式结合，因此 `not` 的优先级比 `and` 和 `not` 都要高。所以，上面的例子里，这个写法你应该是知道哪些地方省略了小括号。

```csharp
if (ch is (not >= '0' or not <= '9') and not '.') ;
```

### 拓展属性模式（Extended Property Pattern）

#### 语法

因为属性模式本身有些地方很鸡肋，因为它可以嵌套，比如下面这样的代码：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father: { Name: "Zhang 'er" },
        Mother: { Name: "Li si" }
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

这是之前的属性递归介绍的代码。这个写法里，`Father` 里再次包含一层大括号。

在新的模式匹配里，为了解决这种大括号嵌套太多层次导致可读性降低的问题，发明了拓展属性模式。拓展属性模式允许将这个代码简写为 `Father.Name`：

```csharp
if (
    zhangSan is
    {
        Name: "Zhang San",
        Age: 24,
        Father.Name: "Zhang 'er",
        Mother.Name: "Li si"
    }
)
{
    Console.WriteLine("Zhang san does satisfy that condition.");
}
```

即少一个大括号的层级级别：`Prop: { NestProp: { } }` 改成 `Prop.NestedProp { }` 的格式。

#### 成员访问运算符的隐式判空

请注意，两种写法是等价的。可能你会认为前者的大括号的层次会让判断逻辑多一次 `null` 的判断：`Prop is not null && Prop.NestedProp is not null`，而 `Prop.NestedProp { }` 这个写法因为 `Prop` 和 `NestedProp` 是直接引用的（用小数点关联起来），所以不会这么做。如果你这么想的话，那你就错了。C# 的拓展属性模式仅仅是为了简化代码才这么写代码的。这里的小数点（成员访问运算符）和我们以前学习的标准的成员访问运算符是不一致的语义：这里只能表示逻辑上的引用的层次关系，而一旦发现 `Prop` 是可空类型的话，那么访问 `NestedProp` 这个嵌套属性的时候就会必然先对外层的 `Prop` 属性数值做一次隐式判空，避免直接访问 `NestedProp` 而产生异常。

另一方面，正是因为编译器会自动隐式产生判空的情况，所以 C# 语法上不允许我们在这个小数点前面加 `?`，即比如 `Prop?.NestedProp: { }`，这么写是错误的语法。假设你想要实现类似的行为，请必须使用 `null or` 模式：

```csharp
Father: null or { Name: "Zhang 'er" }

// Or double negation.
Father: not { Name: not "Zhang 'er" }
```

来代替错误的语法：

```csharp
Father?.Name: "Zhang 'er"
```

### 列表模式（List Pattern）

#### 语法

为了将集合的元素提取出来判断，C# 拥有了列表模式。

列表模式是将一个不知道是不是集合的对象，用列表的格式列举出来，对其中的元素挨个进行判断的模式。

我们使用一对大括号进行判断。使用范围记号 `..` 来表达“这是一个范围”。举个例子：`[1, .., 3]` 表示判断一个序列的第一个元素是不是 1，而最后一个元素是不是 3。所以，自然这个写法就等价于下面这个格式了：

```csharp
if (arr is { Length: 10 } and [1, .., 3])
    // ...
```

它等价于

```csharp
if (arr.Length == 10 && arr[0] == 1 && arr[^1] == 3)
    // ...
```

这里的 `^1` 是 C# 8 里的表达式，表示倒数第一个元素。`^n` 就是倒数第 n 个元素。可以从这个写法里看出，`..` 是灵活的：它不是固定长度，是随着整个模式匹配的序列来确定 `..` 的长度的。这么写是为了简化代码的书写格式。

当然，假设我们判断倒数第二个元素而不是倒数第一个的话，那么我们可以尝试在倒数第一个元素的判断信息上添加弃元记号 `_` 来表达占位：

```csharp
if (arr is { Length: 10 } and [1, .., 3, _])
    // ...
```

弃元记号在这里起到了很重要的作用。一个弃元记号占一个位置，这恰好表达和判断了 `arr[^2]` 的数据，而不是 `arr[^1]`。

#### 预防性长度判断

和前文一致，要用这个模式的话，这个数据类型除了拥有 `Length` 或 `Count` 属性外，索引器成员是必不可少的。另外，如果你不写上范围记号 `..` 的话，就成了判断恰好这些数据了。

```csharp
if (arr is { Length: 10 } and [1, 2, 4]) ;
if (arr is { Length: 10 } and [1, 2, 4, ..]) ;
if (arr is [1, 2, 4]) ;
```

这三个写法的区别是，第一个和第二个是一样的判断：因为 `[1, 2, 4]` 按照顺序，判断的都是前三个数据的数值，因此长度给出后，判断的自然是前三个数据了，而后续的数据不用管，写上 `..` 和不写 `..` 都是没有关系的。但是第三个则不一样了。第三个因为长度模式不存在的关系，模式匹配的长度模式会依赖于 `[1, 2, 4]` 这个列表模式。这个模式只给出了三个元素，因此不写长度模式的话，编译器会认为这个写法下，长度模式是 `{ Length: 3 }`；相反，如果你加上了 `..` 的话，编译器就不再去确认后面的元素信息了。

但是，为了避免抛出异常，C# 会贴心地做一个“预防性判断”。如果 `arr` 没有这么长呢？假设 `arr` 就俩元素，那么判断 `[1, 2, 4, .. ]` 就可能产生一个异常。因此，C# 会自动生成一条预判长度语句：`arr.Length >= 3`。

因此，如下四种写法的等价格式是这样的：

| 语法                                      | 等价判断                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| `arr is { Length: 10 } and [1, 2, 4]`     | `arr.Length == 10 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is { Length: 10 } and [1, 2, 4, ..]` | `arr.Length == 10 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is [1, 2, 4]`                        | `arr.Length == 3 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |
| `arr is [1, 2, 4, ..]`                    | `arr.Length >= 3 && arr[0] == 1 && arr[1] == 2 && arr[2] == 4` |

“默认生成预防性长度判断”这一点比较隐晦，因此你一定要记住。

#### 注意使用条件

在列表模式里，我们约定数据类型必须包含索引器和 `Count` 或 `Length` 属性才可以使用列表模式，下面有两个最容易忽略也会被当成可以用列表模式，实际上不然的数据类型。

1. `Dictionary<TKey, TValue>` 类型；
2. `ICollection<T>` 类型。

首先，字典数据类型的索引器并不是 `int` 数据类型，而是 `TKey` 这个泛型数据类型的。由于 C# 对列表模式的语法设计规则，所以字典无法表达出合适的写法，所以字典类型不支持列表模式；同时，`ICollection<T>` 类型也不支持。原因可能让人大跌眼镜：这个接口压根就没有索引器的成员。可能这一点非常容易忽略掉，但是也很好想到为什么：实现了 `ICollection<T>` 接口的数据类型我们都可以叫它们“集合”。但集合只表示和表达一种合适的存储序列。但序列不一定是连续的，也就是说，你不一定可以使用这个集合类型从前一个元素来找后一个元素。最常见的情况就是“不重复集合”。如果你写了一个不重复集合的话，它可能会使用哈希码来建立列表。那么元素之间就不一定是连续的了，因此你无法定义一种良好的索引机制获取每一个元素。这样的数据类型就不存在索引器一说。正是因为存在这样的集合数据类型不含有索引器，因此你无法对一个这样的数据类型使用列表模式，因为列表模式依赖索引器机制。

#### 无条件成立的列表模式

当然，既然可以允许判断列表模式，那么自然就有 `[..]` 这种写法。这个写法的意思是，集合的元素无条件成立。但是，这个写法还不如不写，对吧。

#### 请一定注意，列表模式不是递归模式的一部分

如题，列表模式是一个单独的模式，你必须声明得和别的模式串联起来用 `and` 或 `or` 连接，所以如下的语法是错的：

```csharp
if (o is int[] [1, _, .., 3]) ;
```

正确的做法是在 `int[]` 和 `[1, _, .., 3]` 之间插入一个 `and`：

```csharp
if (o is int[] and [1, _, .., 3]) ;
```

这一点一定要记住，因为它是对集合作判断，但大多数类型也都不是集合，因此不要想着把它和别的模式放在一起；但是，列表模式允许定义内联变量。

```csharp
if (expr is [_, _, ..] result) ;
```

假设此时的 `expr` 是一个表达式，我们可以使用此语法定义表达结果，并视 `result` 为表达式的运算结果。

还有一个原因是，假设我们想要确定是否一个数据类型是 `int[]` 并且没有元素的话，它的语法是 `is int[] and []`。如果我们去掉 `and` 使之允许，这个语法就成了 `is int[] []`，这会被编译器视为 `is int[][]`，即判断对象是不是一个元素是 `int` 的锯齿数组。因此，不加 `and` 还真不行。

### 分片模式（Slice Pattern）

#### 语法

C# 允许对集合类型的分片。举个例子。

```csharp
if (arr is { Length: 10 } and [_, .. var slice, _])
    // ...
```

这段代码表示，我们将中间的 8 个元素提取出来，变成一个列表。它等价于这个写法：

```csharp
if (arr.Length == 10 && arr[1..^1] is var slice)
    // ...
```

一定要注意，`1..^1` 的语义是“取` [1]` 到 `[^2]` 的元素，而绝对不是取到 `^1`。因为 C# 的范围表达式是取前不取后的（前闭后开的半开区间）。

#### 分片模式的弃元

分片模式也支持弃元。换句话说，我们可以在 `..` 后跟上 `_` 来表示这一截内容我们不参与模式匹配，它和不写弃元符号的时候匹配的内容是完全一致的，只是为了确保语法的灵活性：

```csharp
if (arr is [1, 2, .. _, 3, 4]) ;
```

这里的 `.. _` 的 `_` 就是弃元用法。不过它没有意义，可以省略。

#### 分片模式解构及嵌套模式匹配

分片模式允许我们对范围记号 `..` 的内容进行内联变量定义，但这样的代码仍不够灵活。我还想要内联模式匹配的话，C# 是提供了这个机制的。看看这样的代码是什么意思？

```csharp
if (arr is [_, _, .. [_, .., 7], _]) ;
```

是的，在模式匹配 `[_, _, .. [_, .., 7], _]` 的模式。这个模式要求我们列表集合里至少含有三个以上的元素。接着，`.. [_, .., 7]` 是分片模式的嵌套模式匹配。我们从第三个元素开始判断，我们必须要求从第三个元素开始，我们包含一个序列，它至少有两个元素，且最后一个元素是 7。换句话说，它等价于这样的代码：

```csharp
if (arr is { Length: >= 3 } && arr[2..^1] is { Length: >= 2 } sliced && sliced[^1] == 7) ;
```

注意这里的判断模式。我们用到了三个逻辑表达式，且使用 `&&` 运算符连起来。下面来说一下挨个的具体判断内容。

* 第一个表达式 `arr is { Length: >= 3 }` 判断整个数组是不是不为 `null` 的同时还至少包含 3 个元素。注意这里 `arr` 虽然显然不空，但编译器会自动确保引用类型不空而自动产生该 `is not null` 的模式匹配代码；
* 第二个表达式 `arr[2..^1] is { Length: >= 2 } sliced` 较为复杂。它先获取 `arr` 从第 2 索引元素（第 3 个元素）到倒数第二个元素（一定注意索引运算符是取前不取后的）。这个操作如果获取成功，则返回正常数组，否则会返回 `null`。因此这个 `is { Length: >= 2 }` 验证了 `arr[2..^1]` 是否在取分片数组的时候返回结果是否不为 `null`。如果不为空还要判断它的长度是不是至少包含 2 个元素。接着，如果两个判断逻辑都成功的话，那么 `sliced` 变量就可以使用了，它就是这个分片后的数组结果；
* 第三个表达式 `sliced[^1] == 7` 就是获取整个数组的最后一个元素，看看是不是 7。

所以整个表达式稍显复杂，但按顺序来看的话，就不会有任何问题了。

#### 列表和分片模式的范围记号 `..` 最多只能有一个

虽然有些时候我们很想写这样的代码：

```csharp
if (arr is [.., 40, ..]) ; // Ah?
```

我们的想法是，元素至少有一个，且整个序列里至少有一个元素的结果是 40。

可，C# 编译器并不理解这样的语法，它认为 `..` 的长度不定，因此无法叠加使用，否则将无法确保使用的严谨性，比如这样的代码：

```csharp
if (arr is [.., 10, 20, ..]) ; // Hmmm...
```

这个 `[.., 10, 20, ..]` 就无法理解。而且，这样的代码也是没有意义的：

```csharp
if (arr is [.., .., _]) ; // Also wrong.
```

连续使用两个范围记号 `..`。因此，请一定记住，列表和分片模式的范围记号最多只能有一个。不过，这种不影响：

```csharp
if (arr is [.. [.., _], _]) ; // Correct.
```

这种是分片之后判断序列的模式是 `[.., _]`，因此这个是可以的，因为不会冲突。

#### 分片模式里的模式嵌套

如果这个数组的每一个元素并不是简单的类型，那么它里面可能包含一些别的元素。这个时候我们可能会在分片后，使用别的模式进行模式匹配：

```csharp
if (nestedArr is [_, .. [{ Prop: 42 } sliced, ..], _]) ;
```

比如这里 `.. [{ Prop: 42 } sliced, ..]` 就是一个典型的嵌套用法。`..` 后跟上 `[{ Prop: 42 } sliced, ..]` 是一个嵌套进去的分片模式。其中，它判断分片后的序列至少包含 1 个元素，且第一个元素必须满足模式 `{ Prop: 42 } sliced`，也就是 `Prop` 属性必须是 42。如果成功匹配，那么这个元素名称可以使用 `sliced` 标识符引用。

### 模模式（Cardinality Pattern）

模模式其实就是我们之前的 `{ Length: _ }` 或者 `{ Count: _ }`。这个其实就是属性模式的一种特例——属性名恰好是 `Length` 或 `Count` 而已，只是在 C# 11 里单独为这两个特殊的属性模式匹配的逻辑有所加强：它的代码内容会影响编译器分析代码。

> 模模式的原名叫**长度模式**（Length Pattern），不过在模式匹配里，C# 定义了 `Length` 和 `Count` 可以提供和参与编译器分析非负性的属性名称，length 这个单词可以叫长度，但 count 不能。因为 count 记录的是元素总个数，你只能说集合有多少元素，而不能说集合长度是多少。从定义和名称叫法上 count 和 length 有区别，所以本文改了一个说法。这个模模式的模就是长度的意思，而它恰好就具有两种不同类型 length 和 count 都可涵盖的含义，所以本文介绍的时候将其称为模模式。其中英语术语里的 cardinality 是基数的意思，指的是集合里有多少个元素；不过在计算机科学范畴，cardinality 除了翻译成基数以外，还可以被翻译为“势”。比如说两个集合等势就意味着两个集合的元素是一一对应起来的。这里用不着这么复杂的概念，我们只需要知道它的基本用法表元素总数就可以了。
>
> 不过，如果你在查资料的时候请仍然按照“长度模式”这个术语去查阅，只是本文为了避免二义性和语义冲突而换了一个说法。

早期的长度模式只是一个简单的属性判断，但在 C# 11 里有了列表模式和分片模式，因此在集合里，长度的分析过程变得非常重要。

#### 系统类型的长度属性均假设为非负数

C# 11 开始，系统提供的集合类型里，只要它带有 `Length` 或 `Count` 属性的话，那么编译器会自动假设它非负。换句话说，虽然我们大家都知道，`Length` 和 `Count` 属性返回值是 `int`，它有负整数的范围，但集合的元素总数是不可能为负数的（哪怕是空集合，长度也是 0，也并非负数）。因此，系统会假设这些数据类型（特别是一维数组类型需要注意）一定是非负长度。如果你使用如下代码，编译器会自动报错：

```csharp
if (arr is { Length: -1 }) ;
```

并提示你，数组的长度非负，因此这个属性模式将永远不会匹配成功。

#### 自定义类型的长度模式对编译器的表现行为

这里说一下编译器的处理机制。不论是你定义的集合类型，还是系统给定的数据类型里，长度的非负性质一直是一个正常的逻辑实现。虽然你可以随意给 `Length` 或 `Count` 属性设置为一个负数值，但它并不是正确的实现，因为长度在使用的时候一定是非负的，虽然它的返回值是 `int` 类型包含负数的数值范围。

使用 `int` 类型但不允许非负的原因是因为，`uint` 类型虽然能够保证非负，但它不符合 CLS（公共语言运行时）的标准，也就是说，这样的代码可能只能在 C# 上跑，而同一个 DLL 文件编译出来之后，VB 对这个 `uint` 不支持，因此无法使用这样的代码。因此为了兼容性，我们设置了 `int` 作为理想的返回类型。

而编译器会先查看这个数据类型是否同时包含一个索引器和一个 `Length` 或 `Count` 属性。如果同时存在，那么既然你都能索引了，这个类型的长度就一定不可为负数。但是，如果你没有索引器，但只包含一个单纯的 `Length` 或 `Count` 属性的话，编译器会认为它是普通的属性，因此不会验证负数情况。

所以总的来说，必须同时包含索引器和长度属性（`Length` 或 `Count` 其一）的时候，编译器才会假设长度属性的结果一定非负。

#### 同时包含 `Length` 和 `Count` 属性的时候

如果一个集合同时包含 `Length` 和 `Count` 属性的话，C# 团队的解决办法是，只验证其中的 `Length` 属性一定非负，而 `Count` 属性就不再会假设为非负的情况。举个例子。

```csharp
_ = list is { Count: -1 };
_ = list is { Length: -1 };
```

如果同时有这两个语句，那么只有 `Length` 属性会得到非负数的假设。而 `Count` 属性不论什么时候也不会被假设为非负的，因此这段代码里，如果 `list` 满足这个模式的判断条件（带索引器，同时带有两种长度属性）的话，那么报错信息只会出在第二行上，第一行是没有任何错误信息的。

## 综合内容

下面我们来讨论一些关于前面讲解的模式匹配的综合内容。

### 如何判断集合至少有一个元素

如下的这些模式都可以。

```csharp
int[] arr = { 1, 3, 5, 10 };

// List pattern (Sorted by code length).
if (arr is not (not { } or []))        Console.WriteLine(arr[0]);
if (arr is { Length: not 0 })          Console.WriteLine(arr[0]);
if (arr is not (null or []))           Console.WriteLine(arr[0]);
if (arr is { Length: > 0 })            Console.WriteLine(arr[0]);
if (arr is { } and not [])             Console.WriteLine(arr[0]);
if (arr is [.., _])                    Console.WriteLine(arr[0]);
if (arr is [_, ..])                    Console.WriteLine(arr[0]);

// Slice.
if (arr is [var f, ..])                Console.WriteLine(f);

// Pure check.
if (arr != null && arr.Length != 0)    Console.WriteLine(arr[0]);
if ((arr?.Length ?? -1) != 0)          Console.WriteLine(arr[0]);
```

* **`not (not { } or [])`**：先看内层 `not { } or []`，它表示要么 `not { }`，要么 `[]`。`not { }` 等于 `is null`，而 `[]` 等于 `Length == 0` 属性判断，所以对整个模式取反 `not (not { } or [])` 就是 `not (null or { Length: 0 })`，即不空且至少包含一个元素；
* **`{ Length: not 0 }`**：最基础的属性模式判断。不过这个用法稍微注意一下，如果集合不含 `Length` 属性而是 `Count` 属性，你可能需要改掉这里的 `Length` 名称；
* **`not (null or [])`**：`not { }` 就是 `null`，所以和第一个写法等价；
* **`{ Length: > 0 }`**：和第二个一致，只不过这里是要求 `Length` 必须非负。但是 C# 11 开始模模式必须非负，因此语义上 `> 0` 和 `not 0` 是一致的了；
* **`{ } and not []`**：`{ }` 是 `not null`，`not []` 则是 `Length == 0` 的属性判断，因此结合起来就是序列不空，且至少有一个元素；
* **`[.., _]`** 和 **`[_, ..]`**：这两个写法是等价的，不必多说——列表模式包含一个弃元符号和范围记号，因此序列至少包含一个元素才满足该要求，不过先写 `..` 还是先写 `_` 都无所谓，因为编译器都能识别。

整体来说，看你个人喜好来书写代码。它们最终是一样的代码，都是序列不空且至少有一个元素。

### 递归解构导致的括号满天飞现象

考虑一种极端情况：

```csharp
class S
{
    public void Deconstruct(out S s) => s = this;
}
```

这意味着什么？这意味着我在使用解构模式的时候会产生这样的代码：

```csharp
var s = new S();
if (s is (({}))) ;
```

这个 `(({}))` 是一个嵌套模式，不过没什么特殊意义。我们拆开看看就明白了。首先 `(({}))` 最外层是一个 `()` 模式，它表示对象可以解构就行，因此它等价于 `s is not null`；然后里面一层是 `({})` 的 `()`。它代表我在使用 `Deconstruct` 产生解构对象了之后又一次作判断。但 `Deconstruct` 是我写的一种极端代码：它解构了一个寂寞——返回了它自己。所以内层的 `({})` 的 `()` 还是跟原来判断信息完全一样。最后，最内层有一个空大括号，它表示空属性模式匹配，它依然和 `o is not null` 表达式等价，因此，完整的表达式和你写一个 `s is {}` 或 `s is not null` 没有区别。

你觉得好玩的话，我这还有一个例子。

```csharp
class S
{
    public int Length { get; }
    public S this[int index] => null;

    public void Deconstruct() { }
    public void Deconstruct(out S s) => s = this;
}
```

然后模式匹配：

```csharp
var s = new S();
if (s is () or [] or {}) ;

if (s is ([{}]) or [[[[]]]]) ;
```

蛇皮怪。

我们强烈不建议你这么写代码，我之所以讲这个是为了告诉你有这么一种特殊的情况。

## 总结

下面列举前文所有模式匹配，每一种模式在 C# 里出现和允许使用的版本号。

| 模式类型名称 | 什么版本起可用 | 语法举例                          | 备注                           |
| ------------ | -------------- | --------------------------------- | ------------------------------ |
| 声明模式     | C# 7           | `expr is T v`                     |                                |
| `var` 模式   | C# 7           | `expr is var v`                   |                                |
| 常量模式     | C# 7           | `expr is 0`                       |                                |
| 对位模式     | C# 7           | `expr is (A: _, B: 1, C: "")`     |                                |
| 解构模式     | C# 7           | `expr is var (_, second, last)`   |                                |
| 弃元模式     | C# 7           | `expr is (_, _, _)`               |                                |
| 类型模式     | C# 7           | `expr is T`                       |                                |
| 属性模式     | C# 8           | `expr is { Prop: _ }`             |                                |
| 关系模式     | C# 9           | `expr is < 100`                   |                                |
| 逻辑模式     | C# 9           | `expr is > 0 and < 100`           |                                |
| 扩展属性模式 | C# 10          | `expr is { Parent.Nested: _ }`    |                                |
| 列表模式     | C# 11          | `expr is [1, _, .., _, 3]`        |                                |
| 分片模式     | C# 11          | `expr is [1, _, .. var slice, _]` |                                |
| 模模式       | C# 11          | `expr is { Length: not 0 }`       | 仅为编译器分析，没有新的语法。 |

